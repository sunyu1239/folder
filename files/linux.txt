&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &
&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'    
| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l
|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo "fail"
--------------------- 
作者：panda-star 
来源：CSDN 
原文：https://blog.csdn.net/chinabestchina/article/details/72686002 
版权声明：本文为博主原创文章，转载请附上博文链接！
cd -P 软连接直接目录
cd -L 软连接目录
mkdir -p 逐级建立文件夹
mkdir -p a/b/c
ls -a 显示目录下所有文件包括隐藏文件
ls -l 显示文件详细信息
ls -i 显示文件的节点号
ls -d 显示当前目录
rmdir -p 逐级删除空目录,只能删除空目录
文件具有三个时间，access time访问 modify time修改时间 chang time 状态时间，linux中文件没有创建时间
touch 不是新建文件，是触摸文件，如果文件不存在，则建立该文件，文件如存在，则修改时间戳。本质是修改文件时间戳。
touch -a 只修改文件访问时间access
touch -c 触摸文件时，如不存在，则不建立新文件。
touch -d 修改文件时间戳，指定时间
touch -m 修改文件的数据修改时间modify time
stat 查看文件更详细的信息，包括三个时间。
stat -f 查看文件的文件系统信息
cat concatenate 连接concatenat file and print to standard output
cat 适合查看中等大小的文件，文件过长，翻页也看不到最前面的内容。
cat -A 列出隐藏符号
cat -E 列出行尾回车符
cat -n 显示行号
cat -T 显示TAB符号
cat -V 显示特殊符号
文件过大，使用more查看，分屏显示
more打开交互界面
空格键下页，b上页，/查询，q退出，回车向下滚动一行。
head 只显示文件开头部分，不全显示。
head -n 显示指定行数，默认前10行
head -v 显示文件名
tail 显示文件行尾部分
tail -n 行尾开始，显示指定行尾，默认10行。
tail -f 监听文件新增内容，需要两个终端来体现，一个用tail命令执行监听命令，另一个新开的终端向监听文件里增加新内容。
ubuntu装系统时，分区其实是在未分配硬盘中写入文件系统ext4，文件系统其实是一种文件存贮方式。
ext4格式的文件系统，把分区划分为节点区域和块区域。文件的三个时间，节点信息是存在节点区域的，实际文件内容存贮在块区域，块单元1-4kb，默认4kb。文件内容是放在多个块里面，可能是连续块，也可能是不连续块。
ln make links between files
ln -s 建立软连接
ln -f 如果文件已存在，强制覆盖。
ln /root/cangls /tmp/
#建立硬链接文件，目标文件没有写文件名，会和原名一致,也就是 /root/cangls 和 /tmp/cangls 是硬链接文件.
软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。这是初学者非常容易犯的错误。
在inode信息中，是不会记录文件名称的，文件的inode名记载在文件上级目录块中，该文件的具体内容记载在该文件对应的块中。
当我们查找一个文件，比如 /root/test 时，要经过以下步骤：
首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。
如果有权限，则可以在根目录的 block 中访问到 /root 的文件名及对应的 inode 号。
通过 /root/ 目录的 inode 号，可以查找到 /root/ 目录的 inode 信息，接着判断用户是否有权限访问 /root/ 目录的 block。
如果有权限，则可以从 /root/ 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。
通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。
如果有权限，则可以读取 block 中的数据，这样就完成了 /root/test 文件的读取与访问。

这就是硬链接的原理。硬链接的特点如下：
不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。
不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。
硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。
硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。
硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。
rm -rf/root/test删除链接（软硬都是一样的）。

软链接可以链接目录，也可以跨分区来建立软链接。
硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；
不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。
删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。
软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。
软链接可以链接目录。
软链接可以跨分区。而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。
 
rm 是强大的删除命令，不仅可以删除文件，也可以删除目录。
rm -f 强制删除
rm -r 递归删除
rm -i 删除前会确认，交互删除

cp 复制文件和目录
mv 剪切，移动文件和改名。
mv -f 强制覆盖
mv -i 移动时，如果文件存在，提示是否覆盖
mv -n 文件存在时，不覆盖，也不询问
mv -v 显示详细信息
linux文件权限位：第一位
"-"：普通文件。
"b"：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件 /dev/sda1 就是这种文件。
"c"：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。
"d"：目录文件。Linux 中一切皆文件，所以目录也是文件的一种。
"l"：软链接文件。
"p"：管道符文件。这是一种非常少见的特殊设备文件。
"s"：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样的文件。
rwxrwxrwx.  如果在文件的权限位中含有"."，则表示这个文件受 SELinux 的安全规则管理。
chmod 修改权限命令
chmod -R 递归修改
用户身份（u，g,o,a）+赋予方式（+，-，=）+权限（r，w，x对应4，2，1）
chown 修改用户和用户组
chown -R 逐级修改
chown -R 用户：用户组

chgrp 修改文件和目录的用户组
chgrp 用户组 用户

Linux man命令 
umask 默认权限是 Linux 权限的一种，主要用于让 Linux 中的新建文件和目录拥有默认权限。
在 Linux 中，通过 umask 默认权限来给所有新建立的文件和目录赋予初始权限，这一点和 Windows 不太一样，Windows 是通过继承上级目录的权限来给文件和目录赋予初始权限的。

0022"，其中第一个数字"0"代表的是文件的特殊权限（SetUID、SetGID、Sticky BIT)，特殊权限我们放在后续章节来详细讲解，现在先不讨论。也就是后 3 位数字"022"才是真正的 umask 默认权限。

对文件来讲，新建文件的默认最大权限是 666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。
对目录来讲，新建目录的默认最大权限是 777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。

umask默认权限的计算方法：
文件默认权限：666-022=（rw-rw-rw-）-（----w--w-）=（rw-r--r--）=644 rw-r--r--
目录权限：777-022=（rwxrwxrwx）-（---w--w-）=（rwxr-xr-x）=755 rwxr-xr-x
umask 默认权限的计算是不能直接使用数字相减的（022），通过二进制逻辑与和逻辑非联合运算得到的。
umask 除了临时修改，永久修改则在/etc/profile里修改。

man 显示联机帮助手册 man [选项] 命令
man -f 查看命令有哪个级别的帮助
man -k 查看和命令相关的所有帮助
whatis 命令是干什么的
whereis 命令在哪里
whoami 当前用户是什么

info 查看所有帮助信息 man查看的只是单独的部分信息
help 查看shell内部命令，man 可以查看内外命令。
man help查看内置命令
命令 --help 相当于man命令的简要版。

whereis 搜索系统命令，不能搜文件
whereis -b 只查找二进制命令
whereis -m 只查找帮助文档

which 列出命令的路径 
which 也是搜索系统命令的命令。和 whereis 命令的区别在于，whereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置；
而 which 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。

locate
whereis 和 which 命令都是只能搜索系统命令的命令，而 locate 命令才是可以按照文件名搜索普通文件的命令。
但是 locate 命令的局限也很明显，它只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。
如果要按照复杂条件执行搜索，则只能求助于功能更加强大的 find 命令。locate 命令的优点鮮常明显，那就是搜索速度非常快，而且耗费系统资源非常小。
这是因为 locate 命令不会直接搜索硬盘空间，而会先建立 locate 数据库，然后在数据库中按照文件名进行搜索，是快速的搜索命令。
locate -i忽略大小写
updatedb更新locate数据库，不需要重启，不过有种情况会不行，建立的文件在updatedb.conf里不检索的范围内时，无效。

find 是 Linux 中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode 号等来搜索文件。
但是 find 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 find 命令搜索时，不要指定过大的搜索范围。

find 搜索路径 [选项] 搜索内容
find -name 按照文件名检索
find -iname 按照文件名，不区分大小写检索
find -inum 按照inode号检索
find /sss -name a.txt
find . -size +/-25k 按照文件大小查找
File uses n units of space. The following suffixes can be used:
'b' for 512-byte blocks (this is the default if no suffix is used)
#这是默认单位，如果单位为b或不写单位，则按照 512Byte搜索
'c' for bytes
#搜索单位是c，按照字节搜索
'w' for two-byte words
#搜索单位是w，按照双字节（中文）搜索
'k'for Kilobytes (units of 1024 bytes)
#按照KB单位搜索，必须是小写的k
'M' for Megabytes (units of 1048576 bytes)
#按照MB单位搜索，必须是大写的M
'G' for Gigabytes (units of 1073741824 bytes)
#按照GB单位搜索，必须是大写的G

find -atime [+-] 按照文件访问时间搜索
find -mtime [+-]时间: 按照文改时间搜索
find -ctime [+-]时间: 按照文件修改时间搜索
-5：代表5天内修改的文件。
5：代表前5~6天那一天修改的文件。
+5：代表6天前修改的文件。
find 不仅可以按照 atmie、mtime、ctime 来査找文件的时间，
也可以按照 amin、mmin 和 cmin 来査找文件的时间，区别只是所有 time 选项的默认单位是天，而 min 选项的默认单位是分钟。

按照权限搜索
find . -perm 444 代表査找的权限必须和指定的权限模式一模一样
find . -perm -200 代表的是文件的权限必须全部包含搜索命令指定的权限模式，才可以找到。（也就是说文件权限的每个位置分别需要包含2，0，0的权限，可以有其他的，例如：755就包含200）
？ find .-perm +444 刚刚的"-perm-权限模式"是必须完全包含，才能找到；而"-perm+权限模式"是只要包含任意一个指定权限，就可以找到。

按照所有者和所属组搜索
-uid 用户 ID:按照用户 ID 査找所有者是指定 ID 的文件
-gid 组 ID:按照用户组 ID 査找所属组是指定 ID 的文件
-user 用户名：按照用户名査找所有者是指定用户的文件
-group 组名：按照组名査找所属组是指定用户组的文件
-nouser：査找没有所有者的文件
"-nouser"选项比较常用，主要用于査找垃圾文件。
在 Linux 中，所有的文件都有所有者，只有一种情况例外，那就是外来文件。
比如光盘和 U 盘中的文件如果是由 Windows 复制的，在 Linux 中査看就是没有所有者的文件；再比如手工源码包安装的文件，也有可能没有所有者。

按照文件类型搜索
-type d：查找目录
-type f：查找普通文件
-type l：查找软链接文件
find . -type d 

当用到多个条件查找时，可以用逻辑运算符来运算多个条件。
-a：and逻辑与（两个条件都成立，find 搜索的结果才成立）
-o：or逻辑或（两个条件只要其中一个成立，find 命令就可以找到结果）
-not：not逻辑非
find . -size -20k -a -perm -200 在当前目录下搜索小于2KB，并且文件权限是完全包含200的文件

find 搜索路径 [选项] 搜索内容 -exec 命令2{}\;
"{}"和"\;"是标准格式，只要执行"-exec"选项，这两个符号必须完整输入。
find.-perm 444 -exec ls -l {}\；
"-exec"选项的作用是把 find 命令的结果放入"{}"中，再由命令 2 直接处理。
find . -name a.txt -exec ls -1 {}\;
"-ok"选项和"-exec"选项的作用基本一致，区别在于："-exec"的命令会直接处理，而不询问；"-ok"的命令 2 在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行
find . -name a.txt -ok rm -rf {}\;

.zip压缩文件
zip  压缩名 多个/单个源文件或目录
zip -r 压缩目录

unzip -d： 指定解压缩位置
unzip -d /路径 解压文件.zip

.gz压缩文件
gzip 源文件
gzip -c 将压缩数据输出到标准输出，可以用于保留源文件。
gzip -c anaconda-ks.cfg >anaconda-ks.cfg.gz
使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，#这样可以缩文件的同时不删除源文件。
gzip -r 压缩目录
原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩
在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。
-d：解压缩；
-r：压缩目录；
-v：显示压缩文件的信息；
-数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6；
打包和压缩。打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。为什么要区分这 两个概念呢？
其实这源于Linux中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另外的工具将这一大堆文件先打 成一个包，然后再就原来的压缩程序进行压缩。

gunzip <==> gzip -d
如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下査看这个文本文件中的内容。
zcat a.gz

.bz2格式文件
bzip2
-d：解压缩。
-k：压缩时，保留源文件。
-v：显示压缩的详细信息。
-数字：这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。
大家注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。
bunzip <==> bzip2 -d
-k：解压缩时，保留源文件
和".gz"格式一样，".bz2"格式压缩的纯文本文件也可以不解压缩直接査看，使用的命令是 bzcat
 bzcat install.log.syslog.bz2
 
打包与解打包命令
tar 
-c：打包；
-f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；
-v：显示打包文件过程；
tar -cvf ana.tar anaconda-ks.cfg /tmp/

-x：解打包；
-f：指定压缩包的文件名；
-v：显示打包文件过程；
-t：测试，就是不解打包，只是査看包中有哪些文件；
-C 目录：指定解打包位置；
-z：压缩和解压缩 ".tar.gz"格式
-j：压缩和街压缩 ".tar.bz2"格式
a.txt.tar.gz
a.txt.tar.bz

sync刷新文件系统缓冲区
sync 命令的作用就是把内存中的数据强制向硬盘中保存。
记得关机或重启之前多执行几次 sync 命令

关机和重启
shutdown/reboot关机或重启之前会正确地中止进程及服务。
shutdown
shutdown [选项] 时间 [警告信息]
-c：取消已经执行的 shutdown 命令；
-h：关机；
-r：重启；
shutdown -r 05:30 &
把定义重启命令放入后台，&是后台的意思
shutdown -c
//取消定时重启
shutdown -r +10
#10分钟之后重启
reboot重启
halt/poweroff关机
init 是修改 Linux 运行级别的命令，也可以用于关机和重启。
关机，也就是调用系统的 0 级别。
重启，也就是调用系统的 6 级别。

系统配置工具setup
这是一个综合工具，既可以配置 IP 地址，也可以管理防火墙和系统服务。如果我们需要配置 IP 地址，则只要选择"网络配置"就会开始 IP 地址配置。

ifconfig 是 Linux 中査看和临时修改 IP 地址的命令

ping向网络主机发送ICMP请求
-b: 后面加入广播地址，用于对整个网段进行探测；
-c 次数： 用于指定 ping 的次数；
-s 字节： 指定探测包的大小；
Ctrl+C"快捷键强行中止

我有一台服务器，它有固定的公网 IP 地址，通过 IP 地址可以找到我的服务器。但是我的服务器中既启动了网页服务（Web 服务），又启动了文件传输服务（FTP 服务），
那么你的客户端访问我的服务器，到底应该如何确定你访问的是哪一个服务呢？

端口就是用于网络通信的接口，是数据从传输层向上传递到应用层的数据通道。我们可以理解为每个常规服务都有默认的端口号，通过不同的端口号，我们就可以确定不同的服务。
也就是说，客户端通过 IP 地址访问到我的服务器，如果数据包访问的是 80 端口，则访问的是 Web 服务；而如果数据包访问的是 21 端口，则访问的是 FTP 服务。

netstat 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。
-a：列出所有网络状态，包括 Socket 程序；
-c秒数：指定每隔几秒刷新一次网络状态；
-n：使用 IP 地址和端口号显示，不使用域名与服务名；
-p：显示 PID 和程序名；
-t：显示使用 TCP 协议端口的连接状况；
-u：显示使用 UDP 协议端口的连接状况；
-I：仅显示监听状态的连接；
-r：显示路由表；
1) Proto：网络连接的协议，一般就是 TCP 协议或者 UDP 协议。
2) Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。
3) Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，不具备 ACK 标志的数据包。
4) Local Address：本机的 IP 地址和端口号。
5) ForeignAddress：远程主机的 IP 地址和端口号。
6) State：状态。常见的状态主要有以下几种。
-LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听。
-ESTABLISHED：已经建立连接的状态。如果使用"-I"选项，则看不到已经建立连接的状态。
-SYN_SENT：SYN 发起包，就是主动发起连接的数据包。
-SYN_RECV：接收到主动连接的数据包。
-FIN_WAIT1：正在中断的连接。
-FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。
-TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束。
-CLOSED：套接字没有被使用。

向其他用户发送信息write
write 用户名 [终端号]
信息
Ctrl+D"快捷键保存发送的数据

发送和接收电子邮件mail
mail userl
Subject: hello <-邮件标题
Nice to meet you! <-邮件具体内容
. <-使用.来结束邮件输入
-s： 指定邮件标题
mail -s 'test mail' 用户 <要发送的文件
mail查看已接受到邮件,交互界面输入?，查看命令帮助。

vim是所有linux版本通用的文本编辑器，vi加强版，help vi-diff。
vim三种工作模式
vi进入命令模式。i，a,o进入输入模式，esc退出到命令模式。
命令模式下：进入编辑模式，输入命令，回车结束退到命令模式。
？命令模式下ZZ退出
i：在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动
I：在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行i命令
a：在当前光标所在位置之后插入随后输入的文本
A：在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令
o：在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本
O：在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本。
命令模式下：
w：移动光标到下一个单词的单词首
b：移动光标到上一个单词的单词首
e：移动光标到下一个单词的单词尾
可以使用"$"命令将光标移至行尾，或者使用"0"或"^"命令将光标移至行首。
其实，对于 $ 命令来说，可以使用诸如"n$"之类的命令来将光标移至当前光标所在行的之后 n 行的行尾（n 为数字）;对于"0"命令来说却不可以，但可以用"n^"。
可以直接在命令模式中输入"nG"（n 为数字，G 为大写）或":n"（在编辑模式中输入数字）命令将光标快速地定位到指定行的行首。这种方法对快速移动光标非常有效。

査找指定字符串
在命令模式下进行，输入"/要査找的字符串"，再按一下回车键，就可以从光标所在行开始向下査找指定的字符串。如果要向上査找，则只需输入"？要査找的字符串"即可。
/xxx 光标向下查找
？xxx 光标向上查找
多个xxx匹配时，n向下，N向上。
查找是区分大小写的，编辑模式：set ic 忽略大小写，set noic 不忽略大小写。
查找xxx中有特殊字符，\转译。
命令模式下：
小写"r"可以替换光标所在处的某个字符，将光标移动到想替换的单个字符处，按下"r"键，然后直接输入替换的字符即可。
大写"R"可以从光标所在处开始替换字符，输入会覆盖后面的文本内容，直到按 Esc 键结束。
批量替换格式如下：
替换范围内的字符串：:替换起始处，替换结束处s/源字符串/替换的字符串/g。
替换整篇文档的字符串：:%s/源字符串/替换的字符串/g（如果不加g，则只替换每行第一个找到的字符串）。
:1, $s/root/liudehua/g
或
:%s/root/liudehua/g
在编辑模式下操作的，表示的是从第一行到最后一行，即全文査找"root"，然后替换成"liudehua"。

： 开始行，结束行/被替换的字符/替换字符/g
： %s/被替换字符/替换字符/g
命令模式下：
x删除光标所在位置字符，dd删除光标所在行整行，ndd删除光标下n行，最新一次删除的存储在内存中，p可以粘贴。
dG删除光标所在行到文件结尾，D删除光标到所在行的行尾。
yy复制单行，nyy复制多行。
J去除换行符，作用是合并两行为一行。
u撤销上次的操作。相当于win系统的ctrl+z。
？ Vim 的保存和退出是在命令模式中进行的
字母"w"：保存不退出；
字母"q"：不保存退出；
字符"!"：强制性操作；
编辑模式下： 
： 开始行，终止行d 同样能删除指定行。
：q不保存退出
：w保存但是不退出
：q!强制退出
：w!强制保存
：set nu 显示行号
：set nonu 不显示行号
：set all查看所有的设置参数。
Vim多窗口编辑：
在命令行模式下，：sp /另一个要打开的文件路径（水平分割） ，：vs /另一个要打开的文件路劲。（垂直分割）
另外一种编辑方式：vim -o /文件1的路径  /文件2的路劲
切换窗口ctrl+WW
：r 文件名，复制文件到当前光标下的窗口。
编辑shell文件时，添加注释来回切换模式不好。这时巧用替换命令就可以不用来回切换模式
连续行添加注释：
：起始行，终止行s/^/#/g行首替换#
:起始行，终止行s/^#//g取消注释#
添加//类型的注释：
：起始行，终止行s/^/\/\//g 行首替换//
非连续行的注释：
定义快捷键执行mingling
:map 快捷键 执行命令
：map ^p|#<Esc>
"^P"为定义快捷键"Ctrl+P,必须同时按"Ctrl+V+P"快捷键生成"^P"方可有效。
快捷键定义，输入":unmap^P"即可

linux
源码包到底是什么呢？其实就是软件工程师使用特定的格式和语法所书写的文本代码，是人写的计算机语言的指令，一般由英文单词组成。
源码包需要编译成二进制代码给计算机识别，编译需要消耗时间，有直接的二进制包。
二进制包是 Linux 下的默认安装软件包，所以有时我们也把二进制包称作默认安装软件包。
目前主要有两个系列的二进制包管理系统：一个是 Red Hat 上的 RPM 包管理系统；另一个是 Debian 和 Ubuntu 上的 DPKG 包管理系统。
源码包是多个文件的集合，打包压缩为Mar.gz，称为Tarball，源码包需要到软件官网下载。
源码包中一般包括：源代码文件，配置和检测程序（configure/config），软件安装说明。
源码包的优点如下：
开源。如果你有足够的能力，则可以修改源代码。
可以自由选择所需的功能。
因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也更高。
卸载方便。
dpkg和rpm是二进制包。
RPM 包的缺点如下：
经过编译，不能在看到源代码。
功能选择不如源码包灵活。
依赖性。有时我们会发现，在安装软件包 a 时需要先安装 b 和 c，而在安装 b 时需要先安装 d 和 e。
这就需要先安装 d 和 e，再安装 b 和 c，最后才能安装 a。比如，我买了一个漂亮的灯具，打算安装在客厅里，
可是在安装灯具之前，客厅需要有顶棚，并且顶棚需要刷好油漆。安装软件和装修及其类似，需要有一定的顺序，但是有时依赖性会非常强。
Linux中，区分文件类型，不是靠文件扩展名。
httpd-2.2.15-15.el6.centos.1.i686.rpm 称作包全名
httpd 叫做包名。
安装，升级需要包全名，查询御卸需要包名。
rpm命令安装
rpm安装一般采用默认路径，源码包可以选择路劲，一般/usr/local。
rpm包安装位置功能：
/etc/  配置文件的安装目录
/usr/bin/ 可执行命令的安装目录
/usr/lib/ 程序使用的函数库的保存位置
/usr/share/doc/ 基本的软件使用手册的保存位置
/usr/share/man/ 帮助文件的保存位置
rpm包也可以手动更改安装路径，不过系统默认搜索位置没有变，这样系统就找不到所需文件。
rpm -ivh 包全名
-i 安装
-v 显示安装详细信息
-h 打印#,显示安装进度
rpm -ivh 包全名 包全名 。。。   安装多个软件包
-nodeps 不检测依赖性安装，软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。
如果不管依赖性，想强制安装，则可以使用这个选项。
注意：这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。
-replacefiles 替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报"某个文件已经存在"的错误，
从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。
-replacepkgs 替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。
-force 强制安装。不管是否已经安装，都重新安装。也就是-replacefiles和-replacepkgs的综合。
-test 测试安装，不是真的安装，检测依赖性。
-prefix 指定安装路劲。
lunix终端里面，换行\。
service命令
service 服务器名 参数
start 启动服务
stop 停止服务
restart 重启服务
status 查看服务状态
netstat -tuln | grep 80
rpm 安装软件包，出现依赖性包缺失，失败时需要手动安装缺失的依赖包。
rpm升级
rpm -U 包全名
-U 升级安装。如果没有安装会直接安装；安装了就直接更新。
-F 必须安装了才能升版。
rpm 删除
卸载是有依赖性的。比如，在安装的时候，要先安装 httpd 软件包，再安装 httpd 的功能模块 mod_ssl 包。那么，
在卸载的时候，一定要先卸载 mod_ssl 软件包，再卸载 httpd 软件包，否则就会报错。
软件包卸载和拆除大楼是一样的，你要拆除 2 楼和 3 楼，一定要先拆除 3 楼。
rpm -e 包名
必须依赖性删除，不然报错。
-nocteps 不检测依赖性直接删除，可能导致其他软件挂掉。
rpm查询 /var/lib/rpm/下的是二进制代码，直接进去看是不行的。
rpm 选项 查询对象
-q 包名 查询是否安装改软件包
因为 apache 是已经安装完成的包，所以只需要给出"包名"，系统就可以识别。
而没有安装的包就必须使用"绝对路径+包全名"格式才可以确定包。
前面一直强调的包名和包全名不能写混乱就是这个原因。
rpm -qa 查询所有安装的软件包
rpm -qi 包名 查询软件详细信息
-p 查询未安装软件包
rpm -qip 包全名 查询还没有安装的软件包的详细信息。
查询软件包中的文件列表
rpm -ql 包名  查询已安装软件包中的文件列表
rpm -qlp 包全名 查询未安装软件包中的文件列表。
查询系统文件属于哪个RPM包。
rpm -qf 系统文件名
-f 查询系统文件属于哪个软件包
rpm -qf /bin/ls 查询ls命令由哪个包提供的。
查询软件包所依赖的所有软件包
rpm -qR 包名 
-R 查询软件包的依赖性
rpm -qRp 包名 查询未安装软件包的依赖性
rpm包验证和数字证书：
系统中安装的 RPM 包数量众多，而每个 RPM 包中都包含大量的文件，万一某个文件被误删，或误修改某个文件中的数据，
又或者有人恶意修改了某个文件，我们是否有监控和检测手段发现这些问题呢？
这时候，必须使用 RPM 包校验来确认文件是否被动过手脚。校验其实就是把已经安装的文件和 /var/lib/rpm/ 目录下的数据库内容进行比较，以确定是否有文件被修改。
-V 校验指定包中的文件
rpm -Va 校验所有已安装的软件包
rpm -V 包名 运行后没有提示信息，表示没有被动过。
验证内容中的 8 个信息的具体含义如下。如果没有改变用.占位。
S：文件大小是否改变。
M：文件的类型或文件的权限（rwx）是否改变。
5：文件MD5校验和是否改变（可以看成文件内容是否改变）。
D：设备的主从代码是否改变。
L：文件路径是否改变。
U：文件的属主（所有者）是否改变。
G：文件的属组是否改变。
T：文件的修改时间是否改变。
文件名前面：
c：配置文件（configuration file）。
d：普通文档（documentation）。
g："鬼"文件（ghost file），很少见，就是该文件不应该被这个RPM包包含。
l：授权文件（license file）。
r：描述文件（read me）。

rpm包验证只能对已经安装的 RPM 包中的文件进行校验，
但如果 RPM 包本身就被动过手脚，那么 RPM 包校验就不能解决问题了，必须使用数字证书验证。
数字证书，也叫数字签名，它由软件开发商直接发布。
只要安装了这个数字证书，如果 RPM 包被进行了修改，那么数字证书验证就不能匹配，软件也就不能安装。
数字证书有如下特点：
首先必须找到原厂的公钥文件，然后才能进行安装。
再安装 RPM 包，会去提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。
如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。
rpm --import/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
--import 导入数字证书
查询安装好的数字证书：rpm -qa|grep gpg-pubkey
安装完数字证书之后，系统自行验证。
数字证书也是rpm包。
cpio cpio 命令可以把文件或目录从文件库中提取出来，也可以把文件或目录复制到文件库中。可以把 cpio 命令看成备份或还原命令，它既可数据备份成 cpio 文件库，也可以把 cpio 文件库中的数据还原出来。
cpio 命令最大的问题是不能自己指定备份或还原的文件是什么，而必须由其他命令告诉 cpio 命令要备份和还原哪个文件，这必须依赖数据流重定向的命令。
"-o"模式：指的是 copy-out 模式，就是把数据备份到文件库中；
"-i"模式：指的是 copy-in 模式，就是把数据从文件库中恢复；
"-p"模式：指的是复制模式，就是不把数据备份到 cpio 库中，而是直接复制为其他文件。
-v：显示备份过程；
-c：使用较新的portable format存储方式；
-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes
cpio -o[vcB] > [文件丨设备] 备份   find /etc -print | cpio -ocvB > /root/ etc.cpio
cpio -i[vcdu] < [文件|设备] 恢复
备份时，用的是绝对路劲，那么还原时就会还原到绝对路径。如果用的是相对路径，则还原到当前路径。
find /boot/ -print | cpio -p/tmp/test 备份/boot/目录到/tmp/test/目录中。
cpio是一个工具，用于创建软件档案文件和从档案文件中提取文件。
rpm2cpio 包全名|cpio -idv .文件 绝对路径

rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm
|cpio -idv ./bin/ls ./bin/ls 24772块  提取ls命令文件到当前目录下
cp /root/bin/ls /bin/  把提取出来的ls命令文件复制到/bin/目录下

SRPM包内是源码包，安装方式不同于源码包和rpm安装。
MySQL-5.5.29-2.el6.src.rpm，包命名多了个.src,即.src.rpm。
使用SRPM包之前，需要先安装rpmbuild，接下来使用rpmbuild命令直接安装，或者利用*.spec文件安装。
rpmbuild命令安装：rpmbuild 选项 全包名 这种方式是不用修改源代码的。
-rebuild：编译SRPM包，不会自动安装，等待手工安装；
-recompile:编译SRPM包，同时安装。
rpmbuild - rebuild httpd-2.2.15-5.el6.src.rpm
rpmbuild 目录下子目录：
build 编译过程中产生的数据放在这里
RPMS 编译成功后，生成的RPM包放在这里
sources SRPM包中解压出来的源码包（.tar.gz）保存位置
SPECS 生成的设置文件的安装位置
SRPM 放SRPM包的位置
.spec 文件安装
rpm -i httpd-2.2.15-5.el6.src.rpm 解包不安装
-i 安装
rpmbuild -ba/root/rpmbuild/SPECS/httpd.spec
-ba: 编译，同时生成 RPM 包和 SRPM 包；
-bb: 编译，仅生成 RPM 包；
RPM数据库问题
rpm 执行安装，删除，查询软件包时，请求无法执行，需要重建数据库。
1.删除当前数据库
rm -f /var/lib/rpm/_db.*
2.重建数据库
rpm -rebuilddb
系统入侵时，一切都不再可信。
rpm -ql -dump samba | grep /etc/rc.d/init.d/smb
dump选项查看文件信息
检查实际的文件
ls -l /etc/rc.d/init.d/smb -rwxr-xr-x 1 root root 2087 Sep 2 2006/etc/rc.d/init.d/smb
比较两组文件的信息，如不一样，就确定了被修改。
Linux yum命令 
RPM 包的安装虽然很方便和快捷，但是依赖性实在是很麻烦，尤其是库文件依赖，还要去 rpmfind 网站査找库文件到底属于哪个 RPM 包，从而导致 RPM 包的安装非常烦琐。
yum 在线管理就可以自动处理 RPM 包的依赖性问题，从而大大简化 RPM 包的安装过程。但需要注意的是，首先，yum 安装的还是 RPM 包，
其次，yum 安装是需要有可用的 yum 服务器存在的，当然这个 yum 服务器可以在网上，也可以使用光盘在本地搭建。
yum 源既可以使用网络 yum 源，也可以使用本地光盘作为 yum 源。
使用之前需要安装yum。
yum源配置文件，默认路径：/etc/yum.repos.d/下，扩展名一定是.repo。
下面四个配置文件，默认base文件生效。base.repo中有5个容器。
容器介绍：
[base]：容器名称，一定要放在[]中。
name:容器说明，可以自己随便写。
mirrorlist:镜像站点。这个可以注释掉。
baseurl ：yun源服务器的地址，默认是yum源服务器，是可以使用的。
enabled：次容器是否生效，不写或写成enabled则表示次容器生效，写成enabled=0表示不生效。
gpgcheck：如果为1则表示RPM数字证书生效；如果为0则表示RPM的数字证书不生效。
gpgkey：数字证书的公钥文件保存位置，不用修改。
yum源配置文件默认不需要进行任何修改就可以使用。
配置文件media.repo,是本地光盘作为yum源服务器的模板文件，修改一下就可以使用。
修改其他配置文件扩展名，使他们失效。
yum list 查询yum源服务器上所有可安装的软件列表
yum list 包名 查询是否包含软件包（单个包）
yum search 关键字  搜索yum服务器上所有和关键字相关的软件包。
yum info 软件包名 查询软件包的信息
yum -y install 包名  
-y 不需要确认，直接安装。
yum -y update 升级本机所有软件包
yum remove 软件包名 御卸指定的软件包
查询可以安装的软件组
yum grouplist
yun groupinfo 软件组名 查询软件组中包含的软件
yum groupinstall 软件组名 安装指定软件组
yum groupremove 软件组名  御卸指定软件组
源码包安装：
源码包都是用C语言写的，少部分使用c++和其他语言写的。
安装步骤：
1.下载软件包
2.解压缩。
3.进入解压目录
4.通过./configure 软件配置与检查，这一部的作用：
（1）在安装之前需要检测系统环境是否符合安装要求。
（2）定义需要的功能选项。./configure--help 命令查询支持的功能。
./configure--prefix=路径 指定安装路劲。
（3）把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。
需要注意的是，configure是源码包软件自带的一个脚本程序。
5.make编译
6.make clean 清空编译内容。（之前操作报错的时候才执行）。
7.make install 安装
举例：
1. tar -zxvf httpd-2.2.9.tar.gz|more
2. cd httpd-2.2.9
3. ./configure --prefix=/usr/local/apache2
4. 编译SRPM包，不会自动安装，等待手工安装
5. 安装
源码包删除：
直接找到安装路径，执行删除命令，删除之前需要停止相关服务。
源码包更新：
下载补丁，打上补丁，重新编译和安装。（不用 ./configured 成新的 Makefile 文件，make 命令也只是重新编译数据）
补丁的生成和使用。
diff 选项 old new
-a 将任何文档当作文本文档处理
-b 忽略空格造成的不同
-B 忽略空白行造成的不同
-l 忽略大小造成的不同
-N 当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件。
-r 当比较目录时，递归比较子目录
-u 使用同一输出格式。
 diff -Naur /root/test/old.txt /root/test/new.txt > txt. patch
 生成补丁文件
 旧文件打补丁，patch -pn < 补丁文件
 -pn n为数字，代表按照补丁文件中的路径，指定更新文件的位置。
 "-pn"不好理解，我们说明一下。
 补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中记录的目录不一定是匹配的，所以就需要"-pn"选项来同步两个目录。
 比如，我当前在"/root/test/"目录中（我要打补丁 的旧文件就在当前目录下），补丁文件中记录的文件目录为"/root/test/dd.txt"，
 这时如果写入"-p1"（在补丁文件目录中取消一级目录），那么补丁文件就会打入"root/test/root/test/old.txt"文件中，这显然是不对的。那如果写入的是"-p2"(在补丁文件目录中取消二级目录），
 那么补丁文件就会打入"/root/test/test/old.txt"文件中，这显然也不对。如果写入的是"-p3"(在补丁文件目录中取消三级目录），
 那么补丁文件就会打入"/root/test/old.txt文件中，我们的old.txt文件就在这个目录下，所以应该用"-p3"选项。
"-pn"就是想要在补丁文件中所记录的目录中取消几个"/"，n就是几。去掉目录的目的是和当前所在目录匹配。
如果我的当前所在目录是"/root/"目录呢？因为补丁文件中记录的文件目录为"/root/test/old.txt"，所以这里就应该用"-p2"选项，代表取消两级目录，补丁打在当前目录下的"test/old.txt"文件上。
举例： patch -p3 < txt.patch
给旧文件打补丁，依赖的是补丁文件
补丁文件中记录 的目录和你当前所在目录是需要通过-pn来同步的。
给apache打入补丁：
1.下载补丁mod_proxy_ftp_CVE-2008-2939.diff
2.复制补丁文件到源码解压包 httpd-2.2.9
3.打开补丁文件，查看内容，以便目录同步。
为什么是"-p0"呢？因为我当前在"/root/httpd-2.2.9"目录中，但是补丁文件中记录的目录是"modules/proxy/mod_proxy_ftp.c"，
这就在我当前所在目录中，一个"/"都不需要去掉，所以是"-p0"
4.重新编译make
5.重新安装make install
打补丁的方法会比重新安装少了"./configure"步骤，而且编译时也只是编译变化的地方，所以编译速度也更快。
但是如果没有安装过 httpd-2.2.9，就需要先打入补丁，再依次执行"./configure" "make" "make install"命令。
patch -R < modjDroxy_ftp_CVE-2008-2939.diff 还原补丁，不想要补丁中的内容。
函数库：
函数库其实就是函数，只不过是系统所调用的函数。这样说吧，我写了一个软件，所有的功能都需要我自己完成吗？
其实是不需要的，因为很多功能是别人已经写好的，我只需要拿来用就好了。这些有独立功能并且可以被其他程序调用的程序是函数。
函数库分类：
当其他程序调用函数时，根据是否把函数直接整合到程序中而分为静态函数和动态函数。
静态函数库：
函数库文件一般以*.a扩展名结尾，这种函数库在被程序调用时会被直接整合到程序当中。
优点：程序执行时，不需要在调用外部数据，可以直接执行。
缺点：因为把所有内容都整合到程序中，所以编译文件会比较大，升级比较困难，需要把整个程序重新编译。
动态函数库：
函数库文件通常以"*.so"扩展名结尾，这种函数库在被程序调用时，并没有直接整合到程序当中，
当程序需要用到函数库的功能时，再去读取函数库，在程序中只保存了函数库的指向。
用户执行程序-->程序执行时-->调用函数-->动态函数库-->回传值-->调用函数-->最终执行结果
优点：因为没有把整个函数库整合到程序中，所以文件较小，升级方便，不需要把整个程序重新编译，只需要重新编译安装函数库就好。
缺点：程序在执行时需要调用外部函数，如果这时函数出现问题，或指向位置不正确，那么程序将不能正确执行。
目前 Linux 中的大多数函数库是动态函数库，主要是因为升级方便；但是函数的存放位置非常重要，而且不能更改。
目前被系统程序调用的函数主要存放在"/usr/lib"和"/lib"中，而 Linux 内核所调用的函数库主要存放在"/lib/modules"中。
系统中的可执行程序到底调用了哪些函数库呢
ldd -v 可执行文件名  
-v： 显示详细版本信息
新安装了一个函数库，如何让它被系统识别？其实软件如果是正常安装的，则是不需要手工调整函数库的。但是万一没有安装正确，需要手工安装呢？
那也很简单，只要把函数库放入指定位置，一般放在"/usr/lib"或"/lib"中，然后把函数库所在目录写入"/etc/ld.so.conf"文件中。
ldconfig 重新读取/etc/ld.so.conf文件，把新函数库读入缓存即可。
ldconfig -p 列出系统缓存中所有识别的函数库
Linux用户和用户组管理 
脚本程序并不多见，所以在软件包分类中并没有把它列为一类。
Linux用户和用户组管理 
脚本程序并不多见，所以在软件包分类中并没有把它列为一类。
它更加类似于 Windows 下的程序安装，有一个可执行的安装程序，只要运行安装程序，
然后进行简单的功能定制选择（比如指定安装目录等)，就可以安装成功，只不过是在字符界面完成的。
安装脚本，解压包之后进去，直接进入该目录，运行.sh脚本。

/etc/passwd 保存的是系统中所有用户和用户的主要信息。
这些用户中的绝大多数是系统或服务正常运行所必需的用户，我们把这种用户称为系统用户或伪用户。
系统用户是不能登录系统的，但是这些用户同样也不能被删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。
系统是通过uid识别用户的，0：超级用户，1-499系统用户，500-65536普通用户。
uid用户组
所谓初始组，指用户一登陆录就立刻拥有这个用户组的相关权限。每个用户的初始组只能有一个，一般就是将和这个用户的用户名相同的组名作为这个用户的初始组。
举例来说，我们手工添加用户 lamp，在建立用户 lamp 的同时就会建立 lamp 组作为 lamp 用户的初始组。
所谓附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组要把用户再加入其他的用户组外，这些用户组就是这个用户的附加组。
附加组可以有多个，而且用户可以有这些附加组的权限。
用户的家目录，也就是用户登录后有操作权限的访问目录，我们把这个目录称为用户的家目录。
超级用户的家目录是 /root 目录，普通用户在 /home/ 目录下建立和用户名相同的目录作为家目录，
如 lamp 用户的家目录就是 /home/lamp/ 目录
第7个字段就是shell：
Shell 就是 Linux 的命令解释器。管理员输入的密码都是 ASCII 码，也就是类似 abcd 的英文。但是系统可以识别的编码是类似 0101 的机器语言。
Shell 的作用就是把 ASCII 编码的命令翻译成系统可以识别的机器语言，同时把系统的执行结果翻译为用户可以识别的 ASCII 编码。
Linux 的标准 Shell 就是 /bin/bash。
在 /etc/passw 文件中，大家可以把这个字段理解为用户登录之后所拥有的权限。
/bin/bash 用户拥有权限范围内的所有权限；
/sbin/nologin 用户就不能登陆了。
/usr/bin/passwd 用户可以登录，并且只能修改自己的密码，与登陆无关的命令使用了也是无效的。

/etc/shadow 
这个文件中保存着用户的实际加密密码和密码有效期等参数。我们已经知道这个文件的权限是 000，所以保存的实际加密密码除 root 用户外，其他用户是不能查看的，这样做有效地保证了密码的安全。如果这个文件的权限发生了改变，则需要注意是否是恶意攻击。

/etc/group
这个文件是记录组 ID(GID) 和组名的对应文件。
第二个字段是组密码标志。
用户设置密码是为了验证用户的身份，但是用户组设置密码是用来做什么的呢？
用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，
如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。但是这项功能目前很少使用，我们也很少设置组密码。
如果需要赋予某用户调整某个用户组的权限，则可以使用 sudo 命令代替。
第四个字段是组中的用户：只显示用户的附加组的是本用户组的用户，初始组是本用户组的用户不写进来。即附加用户。
/etc/passwd、/etc/shadow、/etc/group 之间的关系为：先在 /etc/group 文件中查询用户组的 GID 和组名；然后在 /etc/passwd 文件中查找该 GID 是哪个用户的初始组，同时提取这个用户的用户名和 UID；
最后通过 UID 到 /etc/shadow 文件中提取和这个用户相匹配的密码。

/etc/gshadow
Linux useradd命令 
这个文件就是保存组密码的文件。
如果我们给用户组设定了组管理员，并给该用户组设定了组密码，那么组密码就保存在这个文件中，组管理员就可以利用这个密码管理者个用户组了。
第三个字段：组管理员用户名：表示这个用户组的管理员是谁。

useradd 添加新的系统用户
useradd 选项 用户名
-u 指定uid 500之后
-d 指定用户的家目录
-c 用户说明，即/etc/passwd中的注释那部分
-g 指定初始组
-G 指定附加组
-s 指定登陆shell
-e 指定用户的失效日期/etc/shadow中
-o 允许创建的uid相同
-m 建立用户时强制建立用户的家目录
useradd 如果不使用上面的选项，则会进行默认配置，参考/etc/default/useradd和/etc/login.defs。
/etc/skel 定义用户的模板目录的位置，下面的文件都会复制到创建用户的家目录下。
/etc/default/useradd
GR0UP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes

/etc/login.defs
MAIL_DIR /var/spool/mail   指定邮箱默认位置
PASS_MAX_DAYS 99999        指定密码有效期
PASS_MIN_DAYS 0            指定密码修改间隔
PASS_MIN_LEN 5             密码的最小长度
PASS_WARN_AGE 7            密码到期之前，提醒的天数
UID_MIN 500                用户id最小值
UID_MAX 60000              用户id最大值
GID_MIN 500                用户组id最小值
GID_MAX 60000              用户组id最大值
CREATE_HOME yes            指定建立用户时是否自动建立用户的家目录
UMASK 077                  这行指定建立的用户家目录的默认权限，因为 umask 值是 077，所以新建的用户家目录的权限是 700。
USERGROUPS_ENAB yes        这行指定使用命令 userdd 删除用户时，是否删除用户的初始组，默认是删除。
ENCRYPT_METHOD SHA512      这行指定 Linux 用户的密码使用 SHA5121 散列模式加密。这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密。

passwd 修改用户密码
passwd 选项 用户
-S 查询用户密码的状态，即/etc/shadow中的内容，只有root用户可以看。
-l 暂时锁定用户。仅root用户可用
-u 解锁用户，仅root用户可用。
--stdin 可以通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用。
passwd 回车 表示修改当前用户的密码。
想给其他用户设密码，只有两种用户可行：
一种是 root 用户；
另一种是 root 通过 sudo 命令赋予权限的普通用户。
也就是说，普通用户只能修改自己的密码，而不能设定其他用户的密码。
passwd -l 用户，/etc/shadow中的密码位置，密码前加上！！,以此来锁定用户。
passwd -u 用户 解锁被锁定的用户
使用字符串作为用户的密码：
这种做法主要是批量添加用户时，给所有的用户设定一个初始密码。
但是需要注意的是，这样设定的密码会把密码明文保存在历史命令中，会有安全隐患。
所以，如果使用了这种方式修改密码，那么应该记住两件事情：第一，手工清除历史命令；
第二，强制这些新添加的用户在第一次登录时必须修改密码（具体方法参考"chage"命令）。
调用管道符更改密码，例子：
echo "123" | passwd -stdin 用户名

usermod 修改用户信息
usermod 选项 用户名
-u 修改用户uid
-d 修改用户的家目录
-c 修改用户说明（即/etc/passwd中的注释部分字段
-g 修改用户初始组
-G 修改用户附加组
-s 修改用户登录shell
-e 修改用户失效日期
-L 临时锁定用户 在/etc/shadow中的密码前加上！
-U 解锁用户    删除密码前的！
useradd和usermod命令的选项有很多相似的，不过useradd是添加用户，针对新用户时使用的，usermod是修改用户，针对已有用户进行操作的。

chage 命令可以查看和修改/etc/shadow文件的第三个字段到第八个字段的密码状态。
一般直接修改/etc/shadow命令就可以了。
不过chage有一个功能，强制用户在第一次登陆时必须修改密码。
chage 选项 用户名
-l 列出用户的详细密码状态
-d 密码最后一次修改日期（/etc/shadow文件的第三个字段）
-m 密码的两次修改间隔时间（第四个字段））
-M 密码的有效期（第五个字段）
-W 密码修改到期前的警告天数（第六个字段）
-i 天数：密码过期后的宽限天数（第七个字段）
-E 账号失效时间（第八个字段）
chage -d 0 用户名 日期改为0之后，达到用户一登陆就要修改密码的效果。这种操作在批量用户的时候很有效。

usedel 删除用户
-r 删除用户的同时删除用户的家目录。
如果用户的家目录不删除，家目录就会变成没有属主和属组的文件，这样的文件是垃圾文件。
删除用户，如果用户的相关旧文件没有删除干净，重新创建这个用户的时候是会报错的。这个时候，手动删除旧文件，可以解决问题。

id命令可以查询用户的uid，gid和附加组的信息。
列子：
 id lamp
 uid=501(lamp) gid=501(lamp) groups=501(lamp)
 
 su切换不同的用户身份
 su 选项 用户名
 - 选项只使用-，代表连带用户的环境变量一起切换。
 -c 仅执行一次命令，而不切换用户身份。
 "-"不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。
 大家知道环境变量是用来定义用户的操作环境的，如果环境变量没有随用户身份切换，那么很多操作将无法正确执行。
 例如，普通用户 lamp 切换成超级用户 root，但是没有加入"-"，那么虽然是 root 用户，
 但是 $PATH 环境变量还是 lamp 用户的，不包含 /sbin、/usr/sbin 等超级用户命令保存路径，所以无法使用管理员命令；
 而且 root 用户在接收邮件时，还会发现收到的是 lamp 用户的邮件，因为环境变量 $MAIL 没有切换过来。
 su -root -c "useradd user1" 只执行一次命令。
 groupadd 添加用户组
 -g 指定组的id
 
 groupmod 命令用于修改用户组的相关信息。
 -g 修改组id
 -n 修改组名
 不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，
 因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。
 groupdel 删除用户组
 要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。
 gpasswd 用来设定组密码并指定组管理员的
 不过我们在前面已经说了，组密码和组管理员功能很少使用，
 而且完全可以被 sudo 命令取代，所以 gpasswd 命令现在主要用于把用户添加进组或从组中删除。
gpasswd 选项 组名
-a 把用户加入组
-d 把用户从组中删除
usermod和gpasswd都能实现，把用户加入用户组的操作。
usermod 操作的对象是用户；gpasswd操作的对象是组。
推荐使用gpasswd，这个命令既可以加入用户到组，又可以从组中删除用户。

每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。
既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？
当然是初始用户组的组身份生效了，因为初始组是用户一旦登陆就获得的组身份。
也就是说，用户在创建文件后，文件的属组是用户的初始组，因为用户的有效组默认是初始组。
既然用户属于多个用户组，那么能不能改变用户的有效组呢？使用命令 newgrp 就可以切换用户的有效组。
newgrp 组名
例子：
groupadd group1
gpasswd -a 用户 group1
grep 用户 /etc/group
可以发现用户的组变化
...
切换完用户的有效组之后，再创建文件的时候，文件的用户组就是切换之后的组了。
ACL access control list 访问控制列表
普通权限中的三种不够用的时候，使用ACL
mount 显示已经挂载的分区
dumpe2fs 显示指定分区的详细信息
临时开启acl权限：mount -o remount，acl / 重新挂载
永久开启acl权限：/etc/fstab 文件中，在你需要开启 ACL 权限的分区行上（也就是说 ACL 权限针对的是分区），手工在 defaults 后面加入"，acl"即可永久在此分区中开启 ACL 权限。、
重启/重新挂载文件系统，修改生效。

getfacle 文件名前面  
查看acl权限
setfacl 选项 文件名
设定acl权限
-m 设定acl权限。 如果是给予用户 ACL 权限，则使用"u:用户名：权限"格式赋予；如果是给予组 ACL 权限，则使用"g:组名：权限" 格式赋予。
-x：删除指定的 ACL 权限
-b：删除所有的 ACL 权限；
-d：设定默认 ACL 权限。只对目录生效，指目录中新建立的文件拥有此默认权限；
-k：删除默认 ACL 权限；
-R：递归设定 ACL 权限。指设定的 ACL 权限会对目录下的所有子文件生效。
有acl权限的会有+号表示。

mask是最大有效权限。
mask 是用来指定最大有效权限的。mask 的默认权限是 rwx，如果我给 st 用户赋予了 r-x 的 ACL 权限，mj 需要和 mask 的 rwx 权限"相与"才能得到 st 的真正权限，
也就是 r-x "相与"rwxtj 出的值是 r-x，所以 st 用户拥有 r-x 权限。
如果把 mask 的权限改为 r--，和 st 用户的权限相与，也就是 r--"相与"r-x 得出的值是 r--，st 用户的权限就会变为只读。大家可以这么理解：用户和用户组所设定的权限必须在 mask 权限设定的范围之内才能生效，mask权限就是最大有效权限。
不过我们一般不更改 mask 权限，只要给予 mask 最大权限 rwx，那么任何权限和 mask 权限相与，得出的值都是权限本身。
也就是说，我们通过给用户和用户组直接赋予权限，就可以生效，这样做更直观。
setfacl -m m:rx project/ 设定mask权限
默认ACL权限和递归ACL权限
默认 ACL 权限的作用是：如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。默认 ACL 权限只对目录生效。
命令如下：setfacl -m d:u:st:rx /project/
递归 ACL 权限。递归是指父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。
setfacl -m u:st:rx -R/project/
总结一下：默认 ACL 权限指的是针对父目录中新建立的文件和目录会继承父目录的 ACL 权限，格式是"setfacl-m d:u:用户名：权限 文件名"；
递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录继承父目录的 ACL 权限，格式是"setfacl-m u:用户名： 权限 -R 文件名"。
删除指定ACL权限：setfacl -x u:st /project/
删除所有ACL权限：setfacl -b project/

SetUID（SUID）文件特殊权限
普通权限r,w,x.
属主x的位置替换成s。
在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd 文件中，用户的密码实际保存在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow 文件中的加密密码，
但是，看下面的代码：
/etc/passwd 文件的权限是 644，意味着只有超级用户 root 可以读/写，普通用户只有只读权限。/etc/shadow 文件的权限是 000，也就是没有任何权限。这意味着只有超级用户可以读取文件内容，并且可以强制修改文件内容；
而普通用户没有任何针对 /etc/shadow 文件的权限。
普通用户可以修改自己的密码的秘密不在于 /etc/passwd 和 /etc/shadow 这两个文件，而在于 passwd 命令。我们再来看看 passwd 命令的权限：普通用户可以修改自己的密码的秘密不在于 /etc/passwd 和 /etc/shadow 这两个文件，而在于 passwd 命令。我们再来看看 passwd 命令的权限：
ll /usr/bin/passwd
-rwsr-xr-x.1 root root 25980 2月22 2012 /usr/bin/passwd
passwd 命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。
当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。
passwd 命令拥有 SetUID 权限，所有者为 root（Linux 中的命令默认所有者都是 root），
也就是说，当普通用户使用 passwd 命令更改自己的密码的时候，实际上是在用 passwd 命令所有者 root 的身份在执行 passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow 文件，命令执行完成后，该身份也随之消失。
SetUID 的功能可以这样理解：
只有可以执行的二进制程序才能设定 SetUID 权限。
命令执行者要对该程序拥有 x（执行）权限。
命令执行者在执行该程序时获得该程序文件属主的割分（在执行程序的过程中变为文件的属主）。
SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。
chmod u-s /usr/bin/passwd 取消setuid权限。
setuid权限不能随便赋予，其他用户就可以通过被赋予权限的命令来修改系统文件，严重的话会导致系统奔溃。
关键目录应严格控制写权限，比如"/" "/usr"等。
用户的密码设置要严格遵守密码规范。
对系统中默认应该有 SetUID 权限的文件制作一张列表，定时检査有没有列表之外的文件被设置了 SetUID 权限。
可以写个脚本实现这样的功能。
在服务器第一次安装完成后，马上査找系统中所有拥有 SetUID 和 SetGID 权限的文件，把它们记录下来，作为扫描的参考模板。
如果某次扫描的结果和本次保存下来的模板不一致，就说明有文件被修改了 SetUID 和 SetGID 权限
SetGID（SGID）文件特殊权限
属组x的位置替换成s。
SetGID 既可以针对文件生效，也可以针对目录生效，这和 SetUID 明显不同。如果针对文件，那么 SetGID 的含义如下：
只有可执行的二进制程序才能设置 SetGID 权限。
命令执行者要对该程序拥有 x（执行）权限。
命令执行者在执行程序的时候，组身份升级为该程序文件的属组。
SetGID 权限同样只在该程序执行过程中有效，也就是说，组身份改变只在程序执行过程中有效。
 ll /usr/bin/locate
-rwx--s--x 1 root slocate 35612 8月24 2010/usr/bin/locate
当普通用户 lamp 执行 locate 命令时，会发生如下事情：
/usr/bin/locate 是可执行二进制程序，可以被赋予 SetGID 权限。
执行用户 lamp 对 locate 命令拥有执行权限。
执行 locate 命令时，组身份会升级为 slocate 组，而 slocate 组对 /var/lib/mlocate/mlocate.db 数据库拥有 r 权限，
所以普通用户可以使用 locate 命令査询 mlocate.db 数据库。
命令结束，lamp 用户的组身份返回为 lamp 组。
SetGID针对目录的作用
如果 SetGID 针对目录设置，则其含义如下：
普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录。
普通用户在此目录中的有效组会变成此目录的属组。
若普通用户对此目录拥有 w 权限，则新建文件的默认属组是这个目录的属组。

Stick BIT（SBIT）文件特殊权限
Linux文件特殊权限设置 >
Sticky BIT 意为粘着位（或粘滞位），也简称为 SBIT。
粘着位目前只对目录有效。
普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。
如果没有粘着位，那么，因为普通用户拥有 w 权限，所以可以删除此目录下的所有文件，包括其他用户建立的文件。一旦被赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。
其他用户x的位置替换成t。我们使用 lamp 用户在 /tmp/ 目录中建立测试文件 ftest，然后使用 lamp1 用户尝试删除。
如果没有 SBIT 权限，而 /tmp/ 目录的权限是 777，那么 lamp1 用户应该可以删除 ftest 文件。
虽然/tmp/目录的权限是777，但是拥有SBIT权限，所以lamp用户不能删除其他用户建立的文件。
如何设置特殊权限，其实还是依赖 chmod 命令的，只不过文件的普通权限只有三个数字，例如，"755"代表属主拥有读、写、执行权限；属组拥有读、执行权限；其他人拥有读、执行权限。如果把特殊权限也考虑在内，那么权限就应该写成"4755"，其中"4"就是特殊权限 SetUID了，"755"还是代表属主、属组和其他人的权限。
4 代表 SetUID；
2 代表 SetGID；
1 代表 SBIT；
因为这几个特殊权限操作的对象不同，SetUID 只对二进制程序文件有效，SetGID 可以对二进制程序文件和目录有效，但是 SBIT 只对目录有效。所以，如果需要设置特殊权限，则还是需要分开设定的。
还有一个大家要注意的问题，特殊权限只针对具有可执行权限的文件有效，不具有 x 权限的文件被赋予了 SetUID 和 SetGID 权限会被标记为 S，SBIT 权限会被标记为 T，仔细想一下，如果没有可执行权限，则设置特殊权无可意义。
修改文件系统的权限属性chattr，chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。
chattr [+-=] [选项] 文件或目录名
+：増加权限；
-：删除权限；
=：等于某权限；
i：如果对文件设置属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；
a：如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；
e：Linux 中的绝大多数文件都默认拥有 e 属性，表示该文件是使用 ext 文件系统进行存储的，而且不能使用"chattr -e"命令取消 e 属性；
chattr 命令不宜对目录 /、/dev/、/tmp/、/var/ 等进行设置，严重者甚至容易导致系统无法启动。
lsattr 查看文件系统属性
lsattr 选项 文件名

-a：显示所有文件和目录；
-d：如果目标是目录，则仅列出目录本身的属性，而不会列出文件的属性；
lsattr -d /back/log/
-----a------e- /back/log/
查看/back/log/目录，其拥有a和e属性

sudo命令，系统权限管理
管理员作为特权用户，很容易误操作造成不必要的损失。再者，都由 root 管理也怪累的，管理员也是人，也需要留点时间去约约会、看看电影、装装傻、发发呆，不是吗？所以健康的管理方法是在 Linux 服务架构好后，可授权普通用户协助完成日常管理。

现在较为流行的工具是 sudo，几乎所有 Linux 都已默认安装。
还要注意一点，我们在前面介绍的所有权限，比如普通权限、默认权限、ACL权限、特殊权限、文件系统属性权限等操作的对象都是文件和目录，
但是 sudo 的操作对象是系统命令，也就是 root 把本来只能由超级用户执行的命令赋予普通用户执行。
sudo 使用简单，管理员 root 使用 visudo 命令即可编辑其配置文件 /etc/sudoers 进行授权。
root ALL=(ALL) ALL
用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
%wheel ALL=(ALL) ALL
#%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
4 个参数的具体含义如下：
用户名/组名：代表 root 给哪个用户或用户组赋予命令，注意组名加"%"。
用户可以用指定的命令管理指定 IP 地址的服务器。如果写 ALL，则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。如果我们在这里写本机的 IP 地址，则不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何 IP 地址来管理当前服务器。
可使用的身份：就是把来源用户切换成什么身份使用，(ALL) 代表可以切换成任意身份。这个字段可以省略。
授权命令：代表 root 把什么命令授权给普通用户。默认是 ALL，代表任何命令，这当然不行，如果需要给哪个命令授权，则只需写入命令名即可。不过需要注意，一定要写绝对路径。
多个授权命令之间用逗号分隔。

原先每个分区只能格式化为一个文件系统，所以我们可以认为文件系统就是指分区。
不过随着技术的进步，现在一个文件系统可以由几个分区组成，或者一个分区可以格式化为几个不同的文件系统，
所以我们已经不能把文件系统和分区等同对待了。不过，为了便于理解，大家可以把文件系统想象成分区。
硬盘结构
如果从存储数据的介质上来区分，那么硬盘可以分为机械硬盘（Hard Disk Drive, HDD）和固态硬盘（Solid State Disk, SSD），
机械硬盘采用磁性碟片来存储数据，而固态硬盘是通过闪存颗粒来存储数据的。
机械硬盘主要由磁盘盘片、磁头、主轴与传动轴等组成。
硬盘是上下双磁头，盘片在两个磁头中间高速旋转。
也就是说，机械硬盘是上下盘面同时进数据读取的。
机械硬盘的逻辑结构
机械硬盘的逻辑结构主要分为磁道、扇区和拄面。
什么是磁道呢？每个盘片都在逻辑上有很多的同心圆，最外面的同心圆就是 0 磁道。我们将每个同心圆称作磁道（注意，磁道只是逻辑结构，在盘面上并没有真正的同心圆）。硬盘的磁道密度非常高，通常一面上就有上千个磁道。
但是相邻的磁道之间并不是紧挨着的，这是因为磁化单元相隔太近会相互产生影响。
扇区其实是很形象的，大家都见过折叠的纸扇吧，纸扇打开后是半圆形或扇形的，不过这个扇形是由每个扇骨组合形成的。在磁盘上每个同心圆是磁道，从圆心向外呈放射状地产生分割线（扇骨），将每个磁道等分为若干弧段，每个弧段就是一个扇区。
每个扇区的大小是固定的，为 512Byte。扇区也是磁盘的最小存储单位。
柱面又是什么呢？如果硬盘是由多个盘片组成的，每个盘面都被划分为数目相等的磁道，那么所有盘片都会从外向内进行磁道编号，最外侧的就是 0 磁道。
具有相同编号的磁道会形成一个圆柱，这个圆柱就被称作磁盘的柱面.
硬盘的大小是使用"磁头数 x 柱面数 x 扇区数 x 每个扇区的大小"这样的公式来计算的。
磁头数（Heads）表示硬盘共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以 2；柱面数（Cylinders）表示硬盘每面盘片有几条磁道；
扇区数（Sectors）表示每条磁道上有几个扇区；每个扇区的大小一般是 512Byte。
硬盘的接口:
机械硬盘通过接口与计算机主板进行连接。硬盘的读取和写入速度与接口有很大关系。
IDE 硬盘接口（Integrated Drive Eectronics，并口，即电子集成驱动器）也称作"ATA硬盘"或"PATA硬盘"是早期机械硬盘的主要接口，
ATA133 硬盘的理论速度可以达到 133MB/s（此速度为理论平均值）.
SATA 接口（Serial ATA，串口）是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。
目前已经是 SATA 三代，理论传输速度达到 600MB/s（此速度为理论平均值）.
SCSI 接口（Small Computer System Interface，小型计算机系统接口）广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU 占用率低及热插拔等优点，理论传输速度达到 320MB/s。
固态硬盘和传统的机械硬盘最大的区别就是不再采用盘片进行数据存储，而采用存储芯片进行数据存储。固态硬盘的存储芯片主要分为两种：一种是采用闪存作为存储介质的；另一种是采用DRAM作为存储介质的。
目前使用较多的主要是采用闪存作为存储介质的固态硬盘。
固态硬盘因为丟弃了机械硬盘的物理结构，所以相比机械硬盘具有了低能耗、无噪声、抗震动、低散热、体积小和速度快的优势；不过价格相比机械硬盘更高，而且使用寿命有限。

硬盘是用来存储数据的，我们可以将其想象成柜子，只不过柜子是用来存储衣物的。分区就是把一个大柜按照要求分割成几个小柜子（组合衣柜)；
格式化就是在每个小柜子中打入隔断，决定每个隔断的大小和位置，
然后在柜门上贴上标签，标签中写清楚每件衣服保存的隔断的位置和这件衣服的一些特性（比如衣服是谁的，衣服的颜色、大小等）。
很多人认为格式化的目的就是清空数据，其实格式化是为了写入文件系统（就是在硬盘中打入隔断并贴上标签）。
ext4是ext3的进化版，变化如下：
向下兼容 ext3；
最大 1EB 文件系统和16TB文件；
无限数量子目录；
Extents 连续数据块概念；
多块分配、延迟分配、持久预分配；
快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用barrier等；
文件系统到底是如何运作的呢？
文件系统中除要保存文件的数据外，还要保存文件的属性，如文件的权限、所有者、属组和时间参数等内容。
文件系统把文件的数据和属性分开存放，把文件的数据放入 date block 中（数据块，保存文件的具体数据。类似衣柜的隔断，用来真正保存衣物），
把文件的属性保存在 inode  中（i 节点，保存文件属性，如权限、所有者、属组和时间参数等。类似衣柜门上贴的标签，标签中写入衣物的特性）。
每个 block 和 inode 都有序列号，用来区分和编码。
另外，还有一个 super block（超级块）用于记录整个文件系统的信息，如 inode 和 block 的总量、已经使用量和剩余量。
总结一下：
super block（超级块）：记录整个文件系统的信息，包括 block 与 inode 的总量、已经使用的 inode 和 block 的数量、未使用的 inode 和 block 的数量、block 与 inode 的大小、文件系统的挂载时间、最近一次的写入时间、最近一次的磁盘检验时间等。
date block（数据块，也称作block）：用来实际保存数据（柜子的隔断），block 的大小（1KB、2KB 或 4KB）和数量在格式化后就已经决定，不能改变，除非重新格式化。每个 block 只能保存一个文件的数据，如果文件数据小于一个 block 块，那么这个 block 的剩余空间不能被其他文件使用；如果文件数据大于一个 block 块，则要占用多个 block 块。Windows 中磁盘碎片整理工具的原理就是把一个文件占用的多个 block 块尽量整理到一起，这样可以加快读写速度。
inode（i 节点，柜门上的标签）：用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。
大家注意到了吗？在 inode 中并没有保存文件的文件名，那是因为文件名是文件所在目录的数据，所以保存在上一级目录的 block 中。前面章节中在讲权限命令的时候说过，要对文件的上一级目录拥有 w 权限，才能删除目录中的文件，就是因为文件名是保存在目录的 block 中的。
Linux 系统能够支持的文件系统非常多，除 Linux 默认文件系统 ext2、ext3 和 ext4 之外，还能支持 fat16、fat32、NTFS（需要重新编译内核）等 Windows 文件系统。也就是说，Linux 可以通过挂载的方式使用 Windows 文件系统中的数据。
Linux 所能够支持的文件系统在"/usr/src/kemels/当前系统版本/fs"目录中（需要在安装时选择），该目录中的每个子目录都是一个可以识别的文件系统。
下面介绍一下linux支持的文件系统：
ext：Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。
ext2：是 ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 ext2 文件系统。于 1993 年发布，支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB)
ext3：是 ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件
ext4：是 ext3 文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。ext4 的变化可以说是翻天覆地的，比如向下兼容 ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统
swap:swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区
nfs:NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源
iso9660:光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统.
fat:就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat
vfat:就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件
ntfs:就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件
ufs:Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统
proc:Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc
sysfs:和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs
tmpfs:也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区

文件系统查看命令：
通过 df 命令可以査看已经挂载的文件系统的信息包括设备文件名、文件系统总大小、已经使用的大小、剩余大小、使用率和挂载点等。
df [选项] [挂载点或分区设备文件名]
-a：显示所有文件系统信息，包括特殊文件系统，如 /proc、/sysfs；
-h：使用习惯单位显示容量，如 KB、MB 或 GB 等；
-T：显示文件系统类型；
-m：以 MB 为单位显示容量；
-k：以 KB 为单位显示容量。默认以 KB 为单位；
df命令使用后显示的6列：文件系统 类型 容量 已用 可用 已用％ 挂载点
du命令：统计目录或文件所占磁盘空间大小。
du [选项] [目录或文件名]
-a：显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量
-h：使用习惯单位显示磁盘占用量，如 KB、MB 或 GB 等；
-s：统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量

du命令和df命令的区别
有时我们会发现，使用 du 命令和 df 命令去统计分区的使用情况时，得到的数据是不一样的。那是因为df命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文件系统中已经分配的空间大小。也就是说，在使用 df 命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。
而 du 命令是面向文件的，只会计算文件或目录占用的磁盘空间。也就是说，df 命令统计的分区更准确，是真正的空闲空间。

Linux 中所有的存储设备都必须挂载之后才能使用，包括硬盘、U 盘和光盘（swap 分区是系统直接调用的，所以不需要挂载）。
不过，硬盘分区在安装时就已经挂载了，而且会在每次系统启动时自动挂载，所以不需要手工参与。
但是在 Linux 系统中要想使用光盘和 U 盘，就需要学一些挂载命令。
挂载是指把硬盘分区（如分区 /dev/sdb1，其实指的是文件系统）和挂载点（已经建立的空目录）联系起来的过程。
这里需要注意，挂载点必须是目录，而且原则上应该使用空目录作为挂载点。
如果不使用空目录作为挂载点，而使用已经有数据的目录（如 /etc/ 目录）作为挂载点，则会出现什么情况呢？很简单，原先 /etc/ 目录下的数据就查找不到了，在 /etc/ 目录中只能看到新的分区中的数据。这是因为 /etc/ 目录原先并不是单独的分区，而是 / 分区的子目录，所以 /etc/ 目录中的数据实际上保存在 / 分区的 block 中。
但是，现在给 /etc/ 目录单独分区了，再向 /etc/ 目录中保存数据，就会保存在 /etc/ 目录的新分区的 block 中，那么原始数据当然就不能看到了。如果还想访问原始数据，则只能把新分区卸载掉。
mount -l 查询系统中已经挂载的设备，-l会显示卷标名称
mount -a 依据配置文件/etc/fstab的内容，自动挂载
mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点
-t 文件系统：加入文件系统类型来指定挂载的类型，可以是 ext3、ext4、iso9660 等文件系统；
-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载；
-o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则默认值生效。
mount 挂载特殊选项
atime/noatime	更新访问时间/不更新访问时间。在访问分区文件时，是否更新文件的访问时间，默认为更新
async/sync	异步/同步，默认为异步
auto/noauto	自动/手动。如 mount -a 命令执行时，是否会自动安装 /etc/fstab 文件内容挂载，默认为自动
defaults	定义默认值，相当于 rw、suid、dev、exec、auto、nouser、async 这 7 个选项
exec/noexec	执行/不执行。设定是否允许在文件系统中执行可执行文件，默认是允许
remount	重新挂载已经挂载的文件系统，一般用于指定修改特殊权限
rw/ro	读写/只读。文件系统挂载时，是否拥有读写权限，默认是 rw
suid/nosuid	具有/不具有 SetUID 权限。设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有
user/nouser	允许/不允许普通用户挂载。设定文件系统是否允许普通用户挂载，默认是不允许，只有 root 可以挂载分区
usrquota	写入代表文件系统支持用户磁盘配额，默认不支持
grpquota	写入代表文件系统支持组磁盘配额，默认不支持
 mount   查看系统中已经挂载的文件系统，注意有虚拟文件系统
 linux使用光盘/u盘都要先挂载。光盘/u盘弹出之前都要先御载。卸载时必须退出挂载目录。
 umount 设备文件名或挂载点
 Linux dumpe2fs命令 >
计算机系统难免会因为人为的误操作或系统的原因而出现死机或突然断电的情况，这种情况下非常容易造成文件系统的崩溃，严重时甚至会造成硬件损坏。这也是我们一直在强调的服务器一定要先关闭服务再进行重启的原因所在。
fsck命令：检修和修复文件系统
fsck 选项 分区设备文件名
-t 文件系统：指定分区的文件系统；
-A：按照配置文件 /etc/fstab 检查所有分区；
-a：不用显示用户提示，自动修复文件系统；
-C：显示检查分区的进度条；
-f：强制检测。一般 fsck 命令如果没有发现分区有问题，则是不会检测的。如果强制检测，那么不管是否发现问题，都会检测；
-y：自动修复。和 -a 作用一致，不过有些文件系统只支持 -y；
dumpe2fs命令：显示磁盘状态
dumpe2fs 设备文件名
我们在安装操作系统的过程中已经对系统硬盘进行了分区，但是如果我新添加了一块硬盘，想要正常使用，难道需要重新安装操作系统才可以分区吗？
当然不是，在Linux中有专门的分区命令 fdisk 和 parted。其中 fdisk 命令较为常用，但不支持大于 2TB 的分区；
如果需要支持大于 2TB 的分区，则需要使用 parted 命令，当然 parted 命令也能分配较小的分区。
fdisk ~l 列出系统分区
fdisk 设备文件名 给硬盘分区
a	设置可引导标记
b	编辑 bsd 磁盘标签
c	设置 DOS 操作系统兼容标记
d	删除一个分区
1	显示已知的文件系统类型。82 为 Linux swap 分区，83 为 Linux 分区
m	显示帮助菜单
n	新建分区
0	建立空白 DOS 分区表
P	显示分区列表
q	不保存退出
s	新建空白 SUN 磁盘标签
t	改变一个分区的系统 ID
u	改变显示记录单位
V	验证分区表
w	保存退出
X	附加功能（仅专家）
总结，建立主分区的过程就是这样的："fdisk 硬盘名 -> n(新建)->p(建立主分区) -> 1(指定分区号) -> 回车（默认从 1 柱面开始建立分区）-> +5G(指定分区大小)"。当然，我们的分区还没有格式化和挂载，所以还不能使用。
建立完主分区后再建立一个扩展分区，逻辑分区是建立在扩展分区里的。
扩展分区是不能被格式化和直接使用的。所以要在扩展分区里面建立逻辑分区。
所有的分区立过程中如果不保存并退出是不会生效的，所以建立错了也没有关系，使用 q 命令不保存退出即可。
如果使用了 w 命令，就会保存退出。有时因为系统的分区表正忙，所以需要重新启动系统才能使新的分区表生效。
不重启的情况下，使用partprobe命令就行。
mkfs命令：格式化分区（为分区写入文件系统）
分区后完成后，必须格式化写入文件系统才能正常使用。
mkfs 选项 分区设备文件名
-t 文件系统：指定格式化的文件系统，如ext3,ext4。
我们建立了 /dev/sdb1（主分区）、/dev/sdb2（扩展分区）、/dev/sdb5（逻辑分区）和 /dev/sdb6（逻辑分区）这几个分区，其中 /dev/sdb2 不能被格式化。
mkfs 命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是 4096 Bytes），这些默认参数除非特殊清况，否则不需要调整。如果想要调整，就需要使用 mke2fs 命令重新格式化。
mke2fs 选项 分区设备文件名
-t 文件系统：指定格式化成哪个文件系统， 如 ext2、ext3、ext4；
-b 字节：指定 block 的大小；
-i 字节：指定"字节 inode "的比例，也就是多少字节分配一个 inode；
-j：建立带有 ext3 日志功能的文件系统；
-L 卷标名：给文件系统设置卷标名，就不使用 e2label 命令设定了；
想要开机后自动挂载，可以修改系统的自动挂载文件/etc/fstab
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1
第一个字段：分区设备文件名或 UUID（硬盘通用唯一识别码，可以理解为硬盘的 ID）。
这个字段在 CentOS 5.5 系统中是写入分区的卷标名或分区设备文件名的，现在变成了硬盘的 UUID。这样做的好处是当硬盘増加了新的分区，或者分区的顺序改变，或者内核升级后，仍然能够保证分区能够正确地加载，而不至于造成启动障碍。
第二个字段：挂载点。再强调一下，挂载点应该 是已经建立的空目录。
第三个字段：文件系统名称，CentOS 6.3 的默认文件系统应该是 ext4。
第四个字段：挂载参数，这个参数和 mount 命令的挂载参数一致。
第五个字段：指定分区是否被 dump 备份，0 代表不备份，1 代表备份，2 代表不定期备份。
第六个字段：指定分区是否被 fsck 检测，0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。

print命令查看分区表信息，七个信息如下：
Number：分区号
Start：分区起始位置。这里不再像fdisk那样用柱面表示，使用字节表示更加直观。
End：分区结束位置
Size:分区大小
Type：分区类型
FileSystem：文件系统类型
标志：分区的标记
mklabel gpt 修改分区表命令
parted 命令还有一大优势，就是可以调整分区的大小（在 Windows 中也可以实现，不过要么需要转换成动态磁盘，要么需要依赖第三方工具，如硬盘分区魔术师）。起始 Linux 中 LVM 和 RAID 是可以支持分区调整的，不过这两种方法也可以看成动态磁盘方法，使用 parted 命令调整分区更加简单。
注意，parted 调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说，数据不会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题的。另外，要调整大小的分区必须已经建立了文件系统（格式化），否则会报错。
我们在安装系统的时候已经建立了 swap 分区。swap 分区是 Linux 系统的交换分区，当内存不够用的时候，我们使用 swap 分区存放内存中暂时不用的数据。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。
建立新的swap分区：
分区：不管是fdisk还是parted命令，都需要分区
格式化：格式化命令稍有不同，使用mkswap命令把分区格式化成swap分区
使用swap分区
mkswap 设备文件名
free命令，查看内存和swap分区的使用情况，如下内容
total：是指总数；
used：是指已经使用的；
free：是指空闲的；
shared：是指共享的；
buffers：是指缓冲内存数；
cached：是指缓存内存数，单位是KB；
我们需要解释一下 buffers（缓冲）和 cached（缓存）的区别。
简单来讲，cached 是给读取数据时加速的，buffers 是给写入数据加速的。
cached 是指把读取出来的数据保存在内存中，当再次读取时，不用读取硬盘而直接从内存中读取，加速了数据的读取过程；
buffers 是指在写入数据时，先把分散的写入操作保存到内存中，当达到一定程度后再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。
扩大swap分区，把新建立的swap分区加入就行
swapon 分区设备文件名 添加swap分区
swapoff 分区设备文件名 取消新加入的swap分区
如果想要开机就自动挂载，修改/etc/fstab文件，在文件中加入类似/dev/sdb1 swap swapoff
高级文件系统管理，主要包括磁盘配额，lvm逻辑卷管理，raid磁盘阵列。
磁盘配额用来限制普通用户在分区中可以使用的容量和文件个数。
lvm 在不停机和不损失数据的情况下修改分区大小
raid 由几块硬盘或分区组成，拥有数据冗余功能，当其中的某块硬盘或分区损坏时，磁盘或分区中保存的数据不会丢失。

磁盘配额（Quota）就是 Linux 系统中用来限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数的。
限制的用户和用户组只能是普通用户和用户组，也就是说超级用户 root 是不能做磁盘配额的；
磁盘配额限制只能针对分区，而不能针对某个目录；
我们可以限制用户占用的磁盘容量大小（block），当然也能限制用户允许占用的文件个数（inode）。

用户配额和组配额
用户配额是指针对用户个人的配额，而组配额是指针对整个用户组的配额。如果我们需要限制的用户数量并不多，则可以给每个用户单独指定配额。如果用户比较多，那么单独限制太过麻烦，这时我们可以把用户加入某个用户组，然后给组指定配额，就会简单得多。
需要注意的是，组中的用户是共享空间或文件数的。也就是说，如果用户 lamp1、lamp2 和 lamp3 都属于 brother 用户组，我给 brother 用户组分配 100MB 的磁盘空间，那么，这三个用户不是平均分配这 100MB 空间的，而是先到先得，谁先占用，谁就有可能占满这 100MB 空间，后来的就没有空间可用了

磁盘容量限制和文件文件个数限制
我们除了可以通过限制用户可用的 block 数量来限制用户可用的磁盘容量，也可以通过限制用户可用的 inode 数量来限制用户可以上传或新建的文件个数。

软限制和硬限制
软限制大家可为警告限制，硬限制就是真正的限制了。比如，规定软限制为 100MB，硬限制为 200MB,那么，当用户使用的磁盘空间为 100~200MB 时，用户还可以继续上传和新建文件，但是每次登录时都会收到一条警告消息，告诉用户磁盘将满。

宽限时间
如果用户的空间占用数处于软限制和硬限制之间，那么系统会在用户登录时警告用户磁盘将满，但是这个警告不会一直进行，而是有时间限制的，这个时间就是宽限时间，默认是 7 天。
如果到达宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。也就是说，如果软限制是 100MB，硬限制是 200MB，宽限时间是 7天，此时用户占用了 120MB,那么今后 7 天用户每次登录时都会出现磁盘将满的警告，如果用户置之不理，7 天后这个用户的硬限制就会变成 100MB，而不是 200MB 了。
查询磁盘配额有两种方法：
使用quota命令查询用户或用户组的配额；
使用repquota 命令查询整个分区的配额情况
quota 选项 用户名或组名
-u 用户名：查询用户配额
-g 组名：查询组配额
-v 显示详细信息
-s 以习惯单位显示容量大小，如M,G
如果没有达到软限制，grace为空。
repquota 命令查询文件系统配额
repquota 选项 分区名
-a：依据 /etc/mtab 文件查询配额。如果不加 -a 选项，就一定要加分区名；
-u：查询用户配额；
-g：查询组配额；
-v：显示详细信息；
-s：以习惯单位显示容量太小；
磁盘配额的概念是指定的普通用户在指定的分区中使用磁盘空间和文件个数的限制。
所以一定要记得切换用户和建立文件的目录，否则默认全部写入 / 分区，而我们并没有在 / 分区上设定配额。
dd if=/dev/zero of=/disk/tesffile bs=1M count=60 建立tesffile文件，指定文件大小为60MB
在 dd 命令中，if 用于指定输入项，这里我们用 /dev/zero 作为输入项，会不停地向目标文件中写 0；of 用于指定输出项，这里用 /disk/testfilef 作为目标文件；bs 指定每次复制 1MB 数据；count 指定复制 60 次。也就是建立一个大小为 60MB 的 testfile 文件，但是这个文件大小超出了磁盘容量硬限制，所以只建立了 49MB，证明容量限制也生效了。
如果我们需要写脚本建立大量的用户，并给每个用户都自动进行磁盘配额，那么 edquota 命令就不能在脚本中使用了，因为这个命令的操作过程和 vi 类似，需要和管理员产生交互。
种情况下就需要利用 setquota 命令进行设置，这个命令的好处是通过命令行设定配额，而不用和管理员交互设定。
setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名

逻辑卷管理：
分区的时候，大小可能会与实际使用有差错。第一种方式：使用parted命令御卸分区之后重新分配分区。
第二种方式：建立一个更大的分区，复制旧分区的内容到这个新分区，在旧分区建立软连接到新分区的内容就行。
第三种方式：使用lvm随时调正分区大小，此种方式不需要御卸分区，不需要停止服务，数据也不会丢失。
logic volumn manager 是linux对磁盘分区的一种管理机制。
LVM 是在硬盘分区之上建立一个逻辑层，这个逻辑层让多个硬盘或分区看起来像一块逻辑硬盘，然后将这块逻辑硬盘分成逻辑卷之后使用，从而大大提高了分区的灵活性。
我们把真实的物理硬盘或分区称作物理卷（PV）；由多个物理卷组成一块大的逻辑硬盘，叫作卷组（VG）；将卷组划分成多个可以使用的分区，叫作逻辑卷（LV）。
而在 LVM 中最小的存储单位不再是 block，而是物理扩展块（Physical Extend，PE）。 
PE 是用来保存数据的最小单元，我们的数据实际上都是写入 PE 当中的。PE 的大小是可以配置的，默认是 4MB。
建立lvm步骤：
把物理硬盘分成分区，当然也可以是整块物理硬盘；
把物理分区建立为物理卷（PV），也可以直接把整块硬盘都建立为物理卷。
把物理卷整合为卷组（VG）。卷组就已经可以动态地调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。
把卷组再划分为逻辑卷（LV），当然逻辑卷也是可以直接调整大小的。我们说逻辑卷可以想象为分区，所以也需要格式化和挂载。
LVM 最主要的作用是调整分区大小，所以就算在安装时已经安装了 LVM，我们还是需要学习 LVM 的命令