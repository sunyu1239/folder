&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &
&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'    
| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l
|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo "fail"
--------------------- 
作者：panda-star 
来源：CSDN 
原文：https://blog.csdn.net/chinabestchina/article/details/72686002 
版权声明：本文为博主原创文章，转载请附上博文链接！
cd -P 软连接直接目录
cd -L 软连接目录
mkdir -p 逐级建立文件夹
mkdir -p a/b/c
ls -a 显示目录下所有文件包括隐藏文件
ls -l 显示文件详细信息
ls -i 显示文件的节点号
ls -d 显示当前目录
rmdir -p 逐级删除空目录,只能删除空目录
文件具有三个时间，access time访问 modify time修改时间 chang time 状态时间，linux中文件没有创建时间
touch 不是新建文件，是触摸文件，如果文件不存在，则建立该文件，文件如存在，则修改时间戳。本质是修改文件时间戳。
touch -a 只修改文件访问时间access
touch -c 触摸文件时，如不存在，则不建立新文件。
touch -d 修改文件时间戳，指定时间
touch -m 修改文件的数据修改时间modify time
stat 查看文件更详细的信息，包括三个时间。
stat -f 查看文件的文件系统信息
cat concatenate 连接concatenat file and print to standard output
cat 适合查看中等大小的文件，文件过长，翻页也看不到最前面的内容。
cat -A 列出隐藏符号
cat -E 列出行尾回车符
cat -n 显示行号
cat -T 显示TAB符号
cat -V 显示特殊符号
文件过大，使用more查看，分屏显示
more打开交互界面
空格键下页，b上页，/查询，q退出，回车向下滚动一行。
head 只显示文件开头部分，不全显示。
head -n 显示指定行数，默认前10行
head -v 显示文件名
tail 显示文件行尾部分
tail -n 行尾开始，显示指定行尾，默认10行。
tail -f 监听文件新增内容，需要两个终端来体现，一个用tail命令执行监听命令，另一个新开的终端向监听文件里增加新内容。
ubuntu装系统时，分区其实是在未分配硬盘中写入文件系统ext4，文件系统其实是一种文件存贮方式。
ext4格式的文件系统，把分区划分为节点区域和块区域。文件的三个时间，节点信息是存在节点区域的，实际文件内容存贮在块区域，块单元1-4kb，默认4kb。文件内容是放在多个块里面，可能是连续块，也可能是不连续块。
ln make links between files
ln -s 建立软连接
ln -f 如果文件已存在，强制覆盖。
ln /root/cangls /tmp/
#建立硬链接文件，目标文件没有写文件名，会和原名一致,也就是 /root/cangls 和 /tmp/cangls 是硬链接文件.
软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。这是初学者非常容易犯的错误。
在inode信息中，是不会记录文件名称的，文件的inode名记载在文件上级目录块中，该文件的具体内容记载在该文件对应的块中。
当我们查找一个文件，比如 /root/test 时，要经过以下步骤：
首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。
如果有权限，则可以在根目录的 block 中访问到 /root 的文件名及对应的 inode 号。
通过 /root/ 目录的 inode 号，可以查找到 /root/ 目录的 inode 信息，接着判断用户是否有权限访问 /root/ 目录的 block。
如果有权限，则可以从 /root/ 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。
通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。
如果有权限，则可以读取 block 中的数据，这样就完成了 /root/test 文件的读取与访问。

这就是硬链接的原理。硬链接的特点如下：
不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。
不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。
硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。
硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。
硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。
rm -rf/root/test删除链接（软硬都是一样的）。

软链接可以链接目录，也可以跨分区来建立软链接。
硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；
不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。
删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。
软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。
软链接可以链接目录。
软链接可以跨分区。而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。
 
rm 是强大的删除命令，不仅可以删除文件，也可以删除目录。
rm -f 强制删除
rm -r 递归删除
rm -i 删除前会确认，交互删除

cp 复制文件和目录
mv 剪切，移动文件和改名。
mv -f 强制覆盖
mv -i 移动时，如果文件存在，提示是否覆盖
mv -n 文件存在时，不覆盖，也不询问
mv -v 显示详细信息
linux文件权限位：第一位
"-"：普通文件。
"b"：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件 /dev/sda1 就是这种文件。
"c"：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。
"d"：目录文件。Linux 中一切皆文件，所以目录也是文件的一种。
"l"：软链接文件。
"p"：管道符文件。这是一种非常少见的特殊设备文件。
"s"：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样的文件。
rwxrwxrwx.  如果在文件的权限位中含有"."，则表示这个文件受 SELinux 的安全规则管理。
chmod 修改权限命令
chmod -R 递归修改
用户身份（u，g,o,a）+赋予方式（+，-，=）+权限（r，w，x对应4，2，1）
chown 修改用户和用户组
chown -R 逐级修改
chown -R 用户：用户组

chgrp 修改文件和目录的用户组
chgrp 用户组 用户

Linux man命令 
umask 默认权限是 Linux 权限的一种，主要用于让 Linux 中的新建文件和目录拥有默认权限。
在 Linux 中，通过 umask 默认权限来给所有新建立的文件和目录赋予初始权限，这一点和 Windows 不太一样，Windows 是通过继承上级目录的权限来给文件和目录赋予初始权限的。

0022"，其中第一个数字"0"代表的是文件的特殊权限（SetUID、SetGID、Sticky BIT)，特殊权限我们放在后续章节来详细讲解，现在先不讨论。也就是后 3 位数字"022"才是真正的 umask 默认权限。

对文件来讲，新建文件的默认最大权限是 666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。
对目录来讲，新建目录的默认最大权限是 777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。

umask默认权限的计算方法：
文件默认权限：666-022=（rw-rw-rw-）-（----w--w-）=（rw-r--r--）=644 rw-r--r--
目录权限：777-022=（rwxrwxrwx）-（---w--w-）=（rwxr-xr-x）=755 rwxr-xr-x
umask 默认权限的计算是不能直接使用数字相减的（022），通过二进制逻辑与和逻辑非联合运算得到的。
umask 除了临时修改，永久修改则在/etc/profile里修改。

man 显示联机帮助手册 man [选项] 命令
man -f 查看命令有哪个级别的帮助
man -k 查看和命令相关的所有帮助
whatis 命令是干什么的
whereis 命令在哪里
whoami 当前用户是什么

info 查看所有帮助信息 man查看的只是单独的部分信息
help 查看shell内部命令，man 可以查看内外命令。
man help查看内置命令
命令 --help 相当于man命令的简要版。

whereis 搜索系统命令，不能搜文件
whereis -b 只查找二进制命令
whereis -m 只查找帮助文档

which 列出命令的路径 
which 也是搜索系统命令的命令。和 whereis 命令的区别在于，whereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置；
而 which 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。

locate
whereis 和 which 命令都是只能搜索系统命令的命令，而 locate 命令才是可以按照文件名搜索普通文件的命令。
但是 locate 命令的局限也很明显，它只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。
如果要按照复杂条件执行搜索，则只能求助于功能更加强大的 find 命令。locate 命令的优点鮮常明显，那就是搜索速度非常快，而且耗费系统资源非常小。
这是因为 locate 命令不会直接搜索硬盘空间，而会先建立 locate 数据库，然后在数据库中按照文件名进行搜索，是快速的搜索命令。
locate -i忽略大小写
updatedb更新locate数据库，不需要重启，不过有种情况会不行，建立的文件在updatedb.conf里不检索的范围内时，无效。

find 是 Linux 中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode 号等来搜索文件。
但是 find 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 find 命令搜索时，不要指定过大的搜索范围。

find 搜索路径 [选项] 搜索内容
find -name 按照文件名检索
find -iname 按照文件名，不区分大小写检索
find -inum 按照inode号检索
find /sss -name a.txt
find . -size +/-25k 按照文件大小查找
File uses n units of space. The following suffixes can be used:
'b' for 512-byte blocks (this is the default if no suffix is used)
#这是默认单位，如果单位为b或不写单位，则按照 512Byte搜索
'c' for bytes
#搜索单位是c，按照字节搜索
'w' for two-byte words
#搜索单位是w，按照双字节（中文）搜索
'k'for Kilobytes (units of 1024 bytes)
#按照KB单位搜索，必须是小写的k
'M' for Megabytes (units of 1048576 bytes)
#按照MB单位搜索，必须是大写的M
'G' for Gigabytes (units of 1073741824 bytes)
#按照GB单位搜索，必须是大写的G

find -atime [+-] 按照文件访问时间搜索
find -mtime [+-]时间: 按照文改时间搜索
find -ctime [+-]时间: 按照文件修改时间搜索
-5：代表5天内修改的文件。
5：代表前5~6天那一天修改的文件。
+5：代表6天前修改的文件。
find 不仅可以按照 atmie、mtime、ctime 来査找文件的时间，
也可以按照 amin、mmin 和 cmin 来査找文件的时间，区别只是所有 time 选项的默认单位是天，而 min 选项的默认单位是分钟。

按照权限搜索
find . -perm 444 代表査找的权限必须和指定的权限模式一模一样
find . -perm -200 代表的是文件的权限必须全部包含搜索命令指定的权限模式，才可以找到。（也就是说文件权限的每个位置分别需要包含2，0，0的权限，可以有其他的，例如：755就包含200）
？ find .-perm +444 刚刚的"-perm-权限模式"是必须完全包含，才能找到；而"-perm+权限模式"是只要包含任意一个指定权限，就可以找到。

按照所有者和所属组搜索
-uid 用户 ID:按照用户 ID 査找所有者是指定 ID 的文件
-gid 组 ID:按照用户组 ID 査找所属组是指定 ID 的文件
-user 用户名：按照用户名査找所有者是指定用户的文件
-group 组名：按照组名査找所属组是指定用户组的文件
-nouser：査找没有所有者的文件
"-nouser"选项比较常用，主要用于査找垃圾文件。
在 Linux 中，所有的文件都有所有者，只有一种情况例外，那就是外来文件。
比如光盘和 U 盘中的文件如果是由 Windows 复制的，在 Linux 中査看就是没有所有者的文件；再比如手工源码包安装的文件，也有可能没有所有者。

按照文件类型搜索
-type d：查找目录
-type f：查找普通文件
-type l：查找软链接文件
find . -type d 

当用到多个条件查找时，可以用逻辑运算符来运算多个条件。
-a：and逻辑与（两个条件都成立，find 搜索的结果才成立）
-o：or逻辑或（两个条件只要其中一个成立，find 命令就可以找到结果）
-not：not逻辑非
find . -size -20k -a -perm -200 在当前目录下搜索小于2KB，并且文件权限是完全包含200的文件

find 搜索路径 [选项] 搜索内容 -exec 命令2{}\;
"{}"和"\;"是标准格式，只要执行"-exec"选项，这两个符号必须完整输入。
find.-perm 444 -exec ls -l {}\；
"-exec"选项的作用是把 find 命令的结果放入"{}"中，再由命令 2 直接处理。
find . -name a.txt -exec ls -1 {}\;
"-ok"选项和"-exec"选项的作用基本一致，区别在于："-exec"的命令会直接处理，而不询问；"-ok"的命令 2 在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行
find . -name a.txt -ok rm -rf {}\;

.zip压缩文件
zip  压缩名 多个/单个源文件或目录
zip -r 压缩目录

unzip -d： 指定解压缩位置
unzip -d /路径 解压文件.zip

.gz压缩文件
gzip 源文件
gzip -c 将压缩数据输出到标准输出，可以用于保留源文件。
gzip -c anaconda-ks.cfg >anaconda-ks.cfg.gz
使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，#这样可以缩文件的同时不删除源文件。
gzip -r 压缩目录
原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩
在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。
-d：解压缩；
-r：压缩目录；
-v：显示压缩文件的信息；
-数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6；
打包和压缩。打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。为什么要区分这 两个概念呢？
其实这源于Linux中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另外的工具将这一大堆文件先打 成一个包，然后再就原来的压缩程序进行压缩。

gunzip <==> gzip -d
如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下査看这个文本文件中的内容。
zcat a.gz

.bz2格式文件
bzip2
-d：解压缩。
-k：压缩时，保留源文件。
-v：显示压缩的详细信息。
-数字：这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。
大家注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。
bunzip <==> bzip2 -d
-k：解压缩时，保留源文件
和".gz"格式一样，".bz2"格式压缩的纯文本文件也可以不解压缩直接査看，使用的命令是 bzcat
 bzcat install.log.syslog.bz2
 
打包与解打包命令
tar 
-c：打包；
-f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；
-v：显示打包文件过程；
tar -cvf ana.tar anaconda-ks.cfg /tmp/

-x：解打包；
-f：指定压缩包的文件名；
-v：显示打包文件过程；
-t：测试，就是不解打包，只是査看包中有哪些文件；
-C 目录：指定解打包位置；
-z：压缩和解压缩 ".tar.gz"格式
-j：压缩和街压缩 ".tar.bz2"格式
a.txt.tar.gz
a.txt.tar.bz

sync刷新文件系统缓冲区
sync 命令的作用就是把内存中的数据强制向硬盘中保存。
记得关机或重启之前多执行几次 sync 命令

关机和重启
shutdown/reboot关机或重启之前会正确地中止进程及服务。
shutdown
shutdown [选项] 时间 [警告信息]
-c：取消已经执行的 shutdown 命令；
-h：关机；
-r：重启；
shutdown -r 05:30 &
把定义重启命令放入后台，&是后台的意思
shutdown -c
//取消定时重启
shutdown -r +10
#10分钟之后重启
reboot重启
halt/poweroff关机
init 是修改 Linux 运行级别的命令，也可以用于关机和重启。
关机，也就是调用系统的 0 级别。
重启，也就是调用系统的 6 级别。

系统配置工具setup
这是一个综合工具，既可以配置 IP 地址，也可以管理防火墙和系统服务。如果我们需要配置 IP 地址，则只要选择"网络配置"就会开始 IP 地址配置。

ifconfig 是 Linux 中査看和临时修改 IP 地址的命令

ping向网络主机发送ICMP请求
-b: 后面加入广播地址，用于对整个网段进行探测；
-c 次数： 用于指定 ping 的次数；
-s 字节： 指定探测包的大小；
Ctrl+C"快捷键强行中止

我有一台服务器，它有固定的公网 IP 地址，通过 IP 地址可以找到我的服务器。但是我的服务器中既启动了网页服务（Web 服务），又启动了文件传输服务（FTP 服务），
那么你的客户端访问我的服务器，到底应该如何确定你访问的是哪一个服务呢？

端口就是用于网络通信的接口，是数据从传输层向上传递到应用层的数据通道。我们可以理解为每个常规服务都有默认的端口号，通过不同的端口号，我们就可以确定不同的服务。
也就是说，客户端通过 IP 地址访问到我的服务器，如果数据包访问的是 80 端口，则访问的是 Web 服务；而如果数据包访问的是 21 端口，则访问的是 FTP 服务。

netstat 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。
-a：列出所有网络状态，包括 Socket 程序；
-c秒数：指定每隔几秒刷新一次网络状态；
-n：使用 IP 地址和端口号显示，不使用域名与服务名；
-p：显示 PID 和程序名；
-t：显示使用 TCP 协议端口的连接状况；
-u：显示使用 UDP 协议端口的连接状况；
-I：仅显示监听状态的连接；
-r：显示路由表；
1) Proto：网络连接的协议，一般就是 TCP 协议或者 UDP 协议。
2) Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。
3) Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，不具备 ACK 标志的数据包。
4) Local Address：本机的 IP 地址和端口号。
5) ForeignAddress：远程主机的 IP 地址和端口号。
6) State：状态。常见的状态主要有以下几种。
-LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听。
-ESTABLISHED：已经建立连接的状态。如果使用"-I"选项，则看不到已经建立连接的状态。
-SYN_SENT：SYN 发起包，就是主动发起连接的数据包。
-SYN_RECV：接收到主动连接的数据包。
-FIN_WAIT1：正在中断的连接。
-FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。
-TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束。
-CLOSED：套接字没有被使用。

向其他用户发送信息write
write 用户名 [终端号]
信息
Ctrl+D"快捷键保存发送的数据

发送和接收电子邮件mail
mail userl
Subject: hello <-邮件标题
Nice to meet you! <-邮件具体内容
. <-使用.来结束邮件输入
-s： 指定邮件标题
mail -s 'test mail' 用户 <要发送的文件
mail查看已接受到邮件,交互界面输入?，查看命令帮助。

vim是所有linux版本通用的文本编辑器，vi加强版，help vi-diff。
vim三种工作模式
vi进入命令模式。i，a,o进入输入模式，esc退出到命令模式。
命令模式下：进入编辑模式，输入命令，回车结束退到命令模式。
？命令模式下ZZ退出
i：在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动
I：在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行i命令
a：在当前光标所在位置之后插入随后输入的文本
A：在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令
o：在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本
O：在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本。
命令模式下：
w：移动光标到下一个单词的单词首
b：移动光标到上一个单词的单词首
e：移动光标到下一个单词的单词尾
可以使用"$"命令将光标移至行尾，或者使用"0"或"^"命令将光标移至行首。
其实，对于 $ 命令来说，可以使用诸如"n$"之类的命令来将光标移至当前光标所在行的之后 n 行的行尾（n 为数字）;对于"0"命令来说却不可以，但可以用"n^"。
可以直接在命令模式中输入"nG"（n 为数字，G 为大写）或":n"（在编辑模式中输入数字）命令将光标快速地定位到指定行的行首。这种方法对快速移动光标非常有效。

査找指定字符串
在命令模式下进行，输入"/要査找的字符串"，再按一下回车键，就可以从光标所在行开始向下査找指定的字符串。如果要向上査找，则只需输入"？要査找的字符串"即可。
/xxx 光标向下查找
？xxx 光标向上查找
多个xxx匹配时，n向下，N向上。
查找是区分大小写的，编辑模式：set ic 忽略大小写，set noic 不忽略大小写。
查找xxx中有特殊字符，\转译。
命令模式下：
小写"r"可以替换光标所在处的某个字符，将光标移动到想替换的单个字符处，按下"r"键，然后直接输入替换的字符即可。
大写"R"可以从光标所在处开始替换字符，输入会覆盖后面的文本内容，直到按 Esc 键结束。
批量替换格式如下：
替换范围内的字符串：:替换起始处，替换结束处s/源字符串/替换的字符串/g。
替换整篇文档的字符串：:%s/源字符串/替换的字符串/g（如果不加g，则只替换每行第一个找到的字符串）。
:1, $s/root/liudehua/g
或
:%s/root/liudehua/g
在编辑模式下操作的，表示的是从第一行到最后一行，即全文査找"root"，然后替换成"liudehua"。

： 开始行，结束行/被替换的字符/替换字符/g
： %s/被替换字符/替换字符/g
命令模式下：
x删除光标所在位置字符，dd删除光标所在行整行，ndd删除光标下n行，最新一次删除的存储在内存中，p可以粘贴。
dG删除光标所在行到文件结尾，D删除光标到所在行的行尾。
yy复制单行，nyy复制多行。
J去除换行符，作用是合并两行为一行。
u撤销上次的操作。相当于win系统的ctrl+z。
？ Vim 的保存和退出是在命令模式中进行的
字母"w"：保存不退出；
字母"q"：不保存退出；
字符"!"：强制性操作；
编辑模式下： 
： 开始行，终止行d 同样能删除指定行。
：q不保存退出
：w保存但是不退出
：q!强制退出
：w!强制保存
：set nu 显示行号
：set nonu 不显示行号
：set all查看所有的设置参数。
Vim多窗口编辑：
在命令行模式下，：sp /另一个要打开的文件路径（水平分割） ，：vs /另一个要打开的文件路劲。（垂直分割）
另外一种编辑方式：vim -o /文件1的路径  /文件2的路劲
切换窗口ctrl+WW
：r 文件名，复制文件到当前光标下的窗口。
编辑shell文件时，添加注释来回切换模式不好。这时巧用替换命令就可以不用来回切换模式
连续行添加注释：
：起始行，终止行s/^/#/g行首替换#
:起始行，终止行s/^#//g取消注释#
添加//类型的注释：
：起始行，终止行s/^/\/\//g 行首替换//
非连续行的注释：
定义快捷键执行mingling
:map 快捷键 执行命令
：map ^p|#<Esc>
"^P"为定义快捷键"Ctrl+P,必须同时按"Ctrl+V+P"快捷键生成"^P"方可有效。
快捷键定义，输入":unmap^P"即可

linux
源码包到底是什么呢？其实就是软件工程师使用特定的格式和语法所书写的文本代码，是人写的计算机语言的指令，一般由英文单词组成。
源码包需要编译成二进制代码给计算机识别，编译需要消耗时间，有直接的二进制包。
二进制包是 Linux 下的默认安装软件包，所以有时我们也把二进制包称作默认安装软件包。
目前主要有两个系列的二进制包管理系统：一个是 Red Hat 上的 RPM 包管理系统；另一个是 Debian 和 Ubuntu 上的 DPKG 包管理系统。
源码包是多个文件的集合，打包压缩为Mar.gz，称为Tarball，源码包需要到软件官网下载。
源码包中一般包括：源代码文件，配置和检测程序（configure/config），软件安装说明。
源码包的优点如下：
开源。如果你有足够的能力，则可以修改源代码。
可以自由选择所需的功能。
因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也更高。
卸载方便。
dpkg和rpm是二进制包。
RPM 包的缺点如下：
经过编译，不能在看到源代码。
功能选择不如源码包灵活。
依赖性。有时我们会发现，在安装软件包 a 时需要先安装 b 和 c，而在安装 b 时需要先安装 d 和 e。
这就需要先安装 d 和 e，再安装 b 和 c，最后才能安装 a。比如，我买了一个漂亮的灯具，打算安装在客厅里，
可是在安装灯具之前，客厅需要有顶棚，并且顶棚需要刷好油漆。安装软件和装修及其类似，需要有一定的顺序，但是有时依赖性会非常强。
Linux中，区分文件类型，不是靠文件扩展名。
httpd-2.2.15-15.el6.centos.1.i686.rpm 称作包全名
httpd 叫做包名。
安装，升级需要包全名，查询御卸需要包名。
rpm命令安装
rpm安装一般采用默认路径，源码包可以选择路劲，一般/usr/local。
rpm包安装位置功能：
/etc/  配置文件的安装目录
/usr/bin/ 可执行命令的安装目录
/usr/lib/ 程序使用的函数库的保存位置
/usr/share/doc/ 基本的软件使用手册的保存位置
/usr/share/man/ 帮助文件的保存位置
rpm包也可以手动更改安装路径，不过系统默认搜索位置没有变，这样系统就找不到所需文件。
rpm -ivh 包全名
-i 安装
-v 显示安装详细信息
-h 打印#,显示安装进度
rpm -ivh 包全名 包全名 。。。   安装多个软件包
-nodeps 不检测依赖性安装，软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。
如果不管依赖性，想强制安装，则可以使用这个选项。
注意：这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。
-replacefiles 替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报"某个文件已经存在"的错误，
从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。
-replacepkgs 替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。
-force 强制安装。不管是否已经安装，都重新安装。也就是-replacefiles和-replacepkgs的综合。
-test 测试安装，不是真的安装，检测依赖性。
-prefix 指定安装路劲。
lunix终端里面，换行\。
service命令
service 服务器名 参数
start 启动服务
stop 停止服务
restart 重启服务
status 查看服务状态
netstat -tuln | grep 80
rpm 安装软件包，出现依赖性包缺失，失败时需要手动安装缺失的依赖包。
rpm升级
rpm -U 包全名
-U 升级安装。如果没有安装会直接安装；安装了就直接更新。
-F 必须安装了才能升版。
rpm 删除
卸载是有依赖性的。比如，在安装的时候，要先安装 httpd 软件包，再安装 httpd 的功能模块 mod_ssl 包。那么，
在卸载的时候，一定要先卸载 mod_ssl 软件包，再卸载 httpd 软件包，否则就会报错。
软件包卸载和拆除大楼是一样的，你要拆除 2 楼和 3 楼，一定要先拆除 3 楼。
rpm -e 包名
必须依赖性删除，不然报错。
-nocteps 不检测依赖性直接删除，可能导致其他软件挂掉。
rpm查询 /var/lib/rpm/下的是二进制代码，直接进去看是不行的。
rpm 选项 查询对象
-q 包名 查询是否安装改软件包
因为 apache 是已经安装完成的包，所以只需要给出"包名"，系统就可以识别。
而没有安装的包就必须使用"绝对路径+包全名"格式才可以确定包。
前面一直强调的包名和包全名不能写混乱就是这个原因。
rpm -qa 查询所有安装的软件包
rpm -qi 包名 查询软件详细信息
-p 查询未安装软件包
rpm -qip 包全名 查询还没有安装的软件包的详细信息。
查询软件包中的文件列表
rpm -ql 包名  查询已安装软件包中的文件列表
rpm -qlp 包全名 查询未安装软件包中的文件列表。
查询系统文件属于哪个RPM包。
rpm -qf 系统文件名
-f 查询系统文件属于哪个软件包
rpm -qf /bin/ls 查询ls命令由哪个包提供的。
查询软件包所依赖的所有软件包
rpm -qR 包名 
-R 查询软件包的依赖性
rpm -qRp 包名 查询未安装软件包的依赖性
rpm包验证和数字证书：
系统中安装的 RPM 包数量众多，而每个 RPM 包中都包含大量的文件，万一某个文件被误删，或误修改某个文件中的数据，
又或者有人恶意修改了某个文件，我们是否有监控和检测手段发现这些问题呢？
这时候，必须使用 RPM 包校验来确认文件是否被动过手脚。校验其实就是把已经安装的文件和 /var/lib/rpm/ 目录下的数据库内容进行比较，以确定是否有文件被修改。
-V 校验指定包中的文件
rpm -Va 校验所有已安装的软件包
rpm -V 包名 运行后没有提示信息，表示没有被动过。
验证内容中的 8 个信息的具体含义如下。如果没有改变用.占位。
S：文件大小是否改变。
M：文件的类型或文件的权限（rwx）是否改变。
5：文件MD5校验和是否改变（可以看成文件内容是否改变）。
D：设备的主从代码是否改变。
L：文件路径是否改变。
U：文件的属主（所有者）是否改变。
G：文件的属组是否改变。
T：文件的修改时间是否改变。
文件名前面：
c：配置文件（configuration file）。
d：普通文档（documentation）。
g："鬼"文件（ghost file），很少见，就是该文件不应该被这个RPM包包含。
l：授权文件（license file）。
r：描述文件（read me）。

rpm包验证只能对已经安装的 RPM 包中的文件进行校验，
但如果 RPM 包本身就被动过手脚，那么 RPM 包校验就不能解决问题了，必须使用数字证书验证。
数字证书，也叫数字签名，它由软件开发商直接发布。
只要安装了这个数字证书，如果 RPM 包被进行了修改，那么数字证书验证就不能匹配，软件也就不能安装。
数字证书有如下特点：
首先必须找到原厂的公钥文件，然后才能进行安装。
再安装 RPM 包，会去提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。
如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。
rpm --import/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
--import 导入数字证书
查询安装好的数字证书：rpm -qa|grep gpg-pubkey
安装完数字证书之后，系统自行验证。
数字证书也是rpm包。
cpio cpio 命令可以把文件或目录从文件库中提取出来，也可以把文件或目录复制到文件库中。可以把 cpio 命令看成备份或还原命令，它既可数据备份成 cpio 文件库，也可以把 cpio 文件库中的数据还原出来。
cpio 命令最大的问题是不能自己指定备份或还原的文件是什么，而必须由其他命令告诉 cpio 命令要备份和还原哪个文件，这必须依赖数据流重定向的命令。
"-o"模式：指的是 copy-out 模式，就是把数据备份到文件库中；
"-i"模式：指的是 copy-in 模式，就是把数据从文件库中恢复；
"-p"模式：指的是复制模式，就是不把数据备份到 cpio 库中，而是直接复制为其他文件。
-v：显示备份过程；
-c：使用较新的portable format存储方式；
-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes
cpio -o[vcB] > [文件丨设备] 备份   find /etc -print | cpio -ocvB > /root/ etc.cpio
cpio -i[vcdu] < [文件|设备] 恢复
备份时，用的是绝对路劲，那么还原时就会还原到绝对路径。如果用的是相对路径，则还原到当前路径。
find /boot/ -print | cpio -p/tmp/test 备份/boot/目录到/tmp/test/目录中。
cpio是一个工具，用于创建软件档案文件和从档案文件中提取文件。
rpm2cpio 包全名|cpio -idv .文件 绝对路径

rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm
|cpio -idv ./bin/ls ./bin/ls 24772块  提取ls命令文件到当前目录下
cp /root/bin/ls /bin/  把提取出来的ls命令文件复制到/bin/目录下

SRPM包内是源码包，安装方式不同于源码包和rpm安装。
MySQL-5.5.29-2.el6.src.rpm，包命名多了个.src,即.src.rpm。
使用SRPM包之前，需要先安装rpmbuild，接下来使用rpmbuild命令直接安装，或者利用*.spec文件安装。
rpmbuild命令安装：rpmbuild 选项 全包名 这种方式是不用修改源代码的。
-rebuild：编译SRPM包，不会自动安装，等待手工安装；
-recompile:编译SRPM包，同时安装。
rpmbuild - rebuild httpd-2.2.15-5.el6.src.rpm
rpmbuild 目录下子目录：
build 编译过程中产生的数据放在这里
RPMS 编译成功后，生成的RPM包放在这里
sources SRPM包中解压出来的源码包（.tar.gz）保存位置
SPECS 生成的设置文件的安装位置
SRPM 放SRPM包的位置
.spec 文件安装
rpm -i httpd-2.2.15-5.el6.src.rpm 解包不安装
-i 安装
rpmbuild -ba/root/rpmbuild/SPECS/httpd.spec
-ba: 编译，同时生成 RPM 包和 SRPM 包；
-bb: 编译，仅生成 RPM 包；
RPM数据库问题
rpm 执行安装，删除，查询软件包时，请求无法执行，需要重建数据库。
1.删除当前数据库
rm -f /var/lib/rpm/_db.*
2.重建数据库
rpm -rebuilddb
系统入侵时，一切都不再可信。
rpm -ql -dump samba | grep /etc/rc.d/init.d/smb
dump选项查看文件信息
检查实际的文件
ls -l /etc/rc.d/init.d/smb -rwxr-xr-x 1 root root 2087 Sep 2 2006/etc/rc.d/init.d/smb
比较两组文件的信息，如不一样，就确定了被修改。
Linux yum命令 
RPM 包的安装虽然很方便和快捷，但是依赖性实在是很麻烦，尤其是库文件依赖，还要去 rpmfind 网站査找库文件到底属于哪个 RPM 包，从而导致 RPM 包的安装非常烦琐。
yum 在线管理就可以自动处理 RPM 包的依赖性问题，从而大大简化 RPM 包的安装过程。但需要注意的是，首先，yum 安装的还是 RPM 包，
其次，yum 安装是需要有可用的 yum 服务器存在的，当然这个 yum 服务器可以在网上，也可以使用光盘在本地搭建。
yum 源既可以使用网络 yum 源，也可以使用本地光盘作为 yum 源。
使用之前需要安装yum。
yum源配置文件，默认路径：/etc/yum.repos.d/下，扩展名一定是.repo。
下面四个配置文件，默认base文件生效。base.repo中有5个容器。
容器介绍：
[base]：容器名称，一定要放在[]中。
name:容器说明，可以自己随便写。
mirrorlist:镜像站点。这个可以注释掉。
baseurl ：yun源服务器的地址，默认是yum源服务器，是可以使用的。
enabled：次容器是否生效，不写或写成enabled则表示次容器生效，写成enabled=0表示不生效。
gpgcheck：如果为1则表示RPM数字证书生效；如果为0则表示RPM的数字证书不生效。
gpgkey：数字证书的公钥文件保存位置，不用修改。
yum源配置文件默认不需要进行任何修改就可以使用。
配置文件media.repo,是本地光盘作为yum源服务器的模板文件，修改一下就可以使用。
修改其他配置文件扩展名，使他们失效。
yum list 查询yum源服务器上所有可安装的软件列表
yum list 包名 查询是否包含软件包（单个包）
yum search 关键字  搜索yum服务器上所有和关键字相关的软件包。
yum info 软件包名 查询软件包的信息
yum -y install 包名  
-y 不需要确认，直接安装。
yum -y update 升级本机所有软件包
yum remove 软件包名 御卸指定的软件包
查询可以安装的软件组
yum grouplist
yun groupinfo 软件组名 查询软件组中包含的软件
yum groupinstall 软件组名 安装指定软件组
yum groupremove 软件组名  御卸指定软件组
源码包安装：
源码包都是用C语言写的，少部分使用c++和其他语言写的。
安装步骤：
1.下载软件包
2.解压缩。
3.进入解压目录
4.通过./configure 软件配置与检查，这一部的作用：
（1）在安装之前需要检测系统环境是否符合安装要求。
（2）定义需要的功能选项。./configure--help 命令查询支持的功能。
./configure--prefix=路径 指定安装路劲。
（3）把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。
需要注意的是，configure是源码包软件自带的一个脚本程序。
5.make编译
6.make clean 清空编译内容。（之前操作报错的时候才执行）。
7.make install 安装
举例：
1. tar -zxvf httpd-2.2.9.tar.gz|more
2. cd httpd-2.2.9
3. ./configure --prefix=/usr/local/apache2
4. 编译SRPM包，不会自动安装，等待手工安装
5. 安装
源码包删除：
直接找到安装路径，执行删除命令，删除之前需要停止相关服务。
源码包更新：
下载补丁，打上补丁，重新编译和安装。（不用 ./configured 成新的 Makefile 文件，make 命令也只是重新编译数据）
补丁的生成和使用。
diff 选项 old new
-a 将任何文档当作文本文档处理
-b 忽略空格造成的不同
-B 忽略空白行造成的不同
-l 忽略大小造成的不同
-N 当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件。
-r 当比较目录时，递归比较子目录
-u 使用同一输出格式。
 diff -Naur /root/test/old.txt /root/test/new.txt > txt. patch
 生成补丁文件
 旧文件打补丁，patch -pn < 补丁文件
 -pn n为数字，代表按照补丁文件中的路径，指定更新文件的位置。
 "-pn"不好理解，我们说明一下。
 补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中记录的目录不一定是匹配的，所以就需要"-pn"选项来同步两个目录。
 比如，我当前在"/root/test/"目录中（我要打补丁 的旧文件就在当前目录下），补丁文件中记录的文件目录为"/root/test/dd.txt"，
 这时如果写入"-p1"（在补丁文件目录中取消一级目录），那么补丁文件就会打入"root/test/root/test/old.txt"文件中，这显然是不对的。那如果写入的是"-p2"(在补丁文件目录中取消二级目录），
 那么补丁文件就会打入"/root/test/test/old.txt"文件中，这显然也不对。如果写入的是"-p3"(在补丁文件目录中取消三级目录），
 那么补丁文件就会打入"/root/test/old.txt文件中，我们的old.txt文件就在这个目录下，所以应该用"-p3"选项。
"-pn"就是想要在补丁文件中所记录的目录中取消几个"/"，n就是几。去掉目录的目的是和当前所在目录匹配。
如果我的当前所在目录是"/root/"目录呢？因为补丁文件中记录的文件目录为"/root/test/old.txt"，所以这里就应该用"-p2"选项，代表取消两级目录，补丁打在当前目录下的"test/old.txt"文件上。
举例： patch -p3 < txt.patch
给旧文件打补丁，依赖的是补丁文件
补丁文件中记录 的目录和你当前所在目录是需要通过-pn来同步的。
给apache打入补丁：
1.下载补丁mod_proxy_ftp_CVE-2008-2939.diff
2.复制补丁文件到源码解压包 httpd-2.2.9
3.打开补丁文件，查看内容，以便目录同步。
为什么是"-p0"呢？因为我当前在"/root/httpd-2.2.9"目录中，但是补丁文件中记录的目录是"modules/proxy/mod_proxy_ftp.c"，
这就在我当前所在目录中，一个"/"都不需要去掉，所以是"-p0"
4.重新编译make
5.重新安装make install
打补丁的方法会比重新安装少了"./configure"步骤，而且编译时也只是编译变化的地方，所以编译速度也更快。
但是如果没有安装过 httpd-2.2.9，就需要先打入补丁，再依次执行"./configure" "make" "make install"命令。
patch -R < modjDroxy_ftp_CVE-2008-2939.diff 还原补丁，不想要补丁中的内容。
函数库：
函数库其实就是函数，只不过是系统所调用的函数。这样说吧，我写了一个软件，所有的功能都需要我自己完成吗？
其实是不需要的，因为很多功能是别人已经写好的，我只需要拿来用就好了。这些有独立功能并且可以被其他程序调用的程序是函数。
函数库分类：
当其他程序调用函数时，根据是否把函数直接整合到程序中而分为静态函数和动态函数。
静态函数库：
函数库文件一般以*.a扩展名结尾，这种函数库在被程序调用时会被直接整合到程序当中。
优点：程序执行时，不需要在调用外部数据，可以直接执行。
缺点：因为把所有内容都整合到程序中，所以编译文件会比较大，升级比较困难，需要把整个程序重新编译。
动态函数库：
函数库文件通常以"*.so"扩展名结尾，这种函数库在被程序调用时，并没有直接整合到程序当中，
当程序需要用到函数库的功能时，再去读取函数库，在程序中只保存了函数库的指向。
用户执行程序-->程序执行时-->调用函数-->动态函数库-->回传值-->调用函数-->最终执行结果
优点：因为没有把整个函数库整合到程序中，所以文件较小，升级方便，不需要把整个程序重新编译，只需要重新编译安装函数库就好。
缺点：程序在执行时需要调用外部函数，如果这时函数出现问题，或指向位置不正确，那么程序将不能正确执行。
目前 Linux 中的大多数函数库是动态函数库，主要是因为升级方便；但是函数的存放位置非常重要，而且不能更改。
目前被系统程序调用的函数主要存放在"/usr/lib"和"/lib"中，而 Linux 内核所调用的函数库主要存放在"/lib/modules"中。
系统中的可执行程序到底调用了哪些函数库呢
ldd -v 可执行文件名  
-v： 显示详细版本信息
新安装了一个函数库，如何让它被系统识别？其实软件如果是正常安装的，则是不需要手工调整函数库的。但是万一没有安装正确，需要手工安装呢？
那也很简单，只要把函数库放入指定位置，一般放在"/usr/lib"或"/lib"中，然后把函数库所在目录写入"/etc/ld.so.conf"文件中。
ldconfig 重新读取/etc/ld.so.conf文件，把新函数库读入缓存即可。
ldconfig -p 列出系统缓存中所有识别的函数库
Linux用户和用户组管理 
脚本程序并不多见，所以在软件包分类中并没有把它列为一类。
Linux用户和用户组管理 
脚本程序并不多见，所以在软件包分类中并没有把它列为一类。
它更加类似于 Windows 下的程序安装，有一个可执行的安装程序，只要运行安装程序，
然后进行简单的功能定制选择（比如指定安装目录等)，就可以安装成功，只不过是在字符界面完成的。
安装脚本，解压包之后进去，直接进入该目录，运行.sh脚本。

/etc/passwd 保存的是系统中所有用户和用户的主要信息。
这些用户中的绝大多数是系统或服务正常运行所必需的用户，我们把这种用户称为系统用户或伪用户。
系统用户是不能登录系统的，但是这些用户同样也不能被删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。
