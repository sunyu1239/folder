static{}静态代码块与{}非静态代码块(构造代码块)
相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。
不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。

执行顺序：静态代码块！--非静态代码块！--默认构造方法！--

非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。

移位运算符：小数点位置不动，移动数字。因为是二进制，所以移动一位就是操作一次2。

RandomAccess接口：快速访问标识。

对象的内置锁和对象的状态之间是没有内在的关联的，虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定通过内置锁来保护。
当获取到与对象关联的内置锁时，并不能阻止其他线程访问该对象，当某个线程获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，是为了免去显式地创建锁对象。
synchronized只是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，并不能阻止其他线程访问不需要获得该内置锁的方法。

类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里的重点在下面这块代码，synchronized同时修饰静态和非静态方法
（个人阅读上文得出理解：对象都是有锁的，只是一般是不用的。用的时候需要用synchronized关键字声明就可以了，告诉内存，这一部分代码需要先获取对象的锁之后才能执行。）

synchronized（...），括号里面的是声明锁的类型。对象锁还是类锁。这两个锁之间是不相互影响的。类锁不是真的类锁，只是用来区分静态方法和对象方法的一种叫法。

（个人理解：对象多线程都能访问，也能执行对象的不需要锁的方法）

volatile是轻量级的同步机制，共享变量用volatile修饰的话，可以确保多线程中，任意一个线程对共享变量的写操作能立刻同步到所有其他线程中去。
volatile还有一个作用：禁止指令重排序优化。

锁状态：无状态，偏向锁状态，轻量级锁状态，重量级锁状态。等级只升不降。

锁竞争：访问资源在锁住的前提下，其他多个线程等待获取锁的现象就是锁竞争。

因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。
为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。

公平锁：synchronized是非公平锁，reentrantlock可以实现公平锁，公平锁：多线程等待，先等待的线程先获取锁。
jdk1.6之后synchronized和reentrantlock的性能差不多了。

锁分为乐观锁和悲观锁。
悲观锁：synchronized和reentrantlock
乐观锁：版本机制，cas算法（compare and swap）

java泛型：
？ 表示不确定的java类型
T (type) 表示具体的一个java类型
K V (key value) 分别代表java键值中的Key Value
E (element) 代表Element

Class<T>在实例化的时候，T要替换成具体类
Class<?>它是个通配泛型，?可以代表任何类型，主要用于声明时的限制情况

泛型是编译时期起作用。

回调函数是一个通过函数指针调用的函数。java回调函数是多态的一种运用。

回调的核心就是回调方将本身即this传递给调用方，这样调用方就可以在调用完毕之后告诉回调方它想要知道的信息。回调是一种思想、是一种机制